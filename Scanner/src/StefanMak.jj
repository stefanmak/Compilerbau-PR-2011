/** * Compiler of STEFAN MAK * options where taken from the example file generated by JavaCC */options{  JDK_VERSION = "1.5";}PARSER_BEGIN(StefanMak)import yapl.interfaces.*;import yapl.lib.*;import java.io.FileInputStream;import java.io.File;import java.io.IOException;/** Scanner for Compiler Milestone 1 */public class StefanMak{  /** Program Name for failure and debugging*/	  private static String program_name;    /** Main entry point. */  public static void main(String args []) throws ParseException, TokenMgrError  {	/** Declare variables for program read*/	File file = null;	FileInputStream fis = null;		/** Read YAPL File from file */	if(args.length != 0)	{		try		{	    			file = new File(args[0]);			fis = new FileInputStream(file);		}catch(IOException ex)		{		  System.err.println(ex);		}	}else	{	  System.out.println("YAPL Program as first parameter needed...");	  System.out.println("System exit...");	  System.exit(0);	}		/** Give my Parser the InputStream to start the work */ 	    StefanMak parser = new StefanMak(fis);    	try	    {	      parser.Start();	      /** Parsing was correct and complete */	      CompilerMessage.printOK(StefanMak.program_name);  	    }	    catch (TokenMgrError ex)	    {	      /** Lexical Error etc. occured */	      	      CompilerMessage.printError(ex,StefanMak.program_name);	    }	    catch (ParseException ex)	    {	      /** Parse Error occured */	      CompilerMessage.printError(ex,StefanMak.program_name);	    }		    	  }}PARSER_END(StefanMak)/** Skip NewLines etc. by parsing... (taken from example)*/SKIP :{  " "| "\r"| "\t"| "\n"}SPECIAL_TOKEN : /* for comments - not necessary nested */{    < COMMENT : "/*" (~[])* "*/" >}TOKEN : /* Elementary Words/Characters to prevent warnings*/{  < LPAR : "(" >| < RPAR : ")" >| < LBRACKET : "[" >| < RBRACKET : "]" >| < COMMA : "," >| < SEMICOLON : ";" >| < DOT : "." >| < IS : "=" >| < COLON : ":" >| < IF : "If" >| < ENDIF : "EndIf" >| < THEN : "Then" >| < ELSE : "Else" >| < OR : "Or" >| < VOID : "void" >| < AND : "And" >| < TRUE : "True" >| < FALSE : "False" >| < WHILE : "While" >| < ENDWHILE : "EndWhile" >| < DO : "Do" >| < RETURN : "Return" >| < WRITE : "Write" >| < BEGIN : "Begin" >| < END : "End" >| < PROCEDURE : "Procedure" >| < PROGRAM : "Program" >| < INTEGER : "int" >| < BOOLEAN : "bool" >| < CONST : "Const" >| < DECLARE : "Declare" >| < READONLY : "readonly" >| < NEW : "new" >| < BLANK : "#" >} TOKEN : /* Operations */{  < RELOP : "<" | "<=" | ">=" | ">" >| < EQUALOP : "==" | "!=" >| < ADDOP : "+" | "-" >| < MULOP : "*" | "/" | "%" >}TOKEN : /* Basic Elements*/{  < NUMBER : < DIGIT > (< DIGIT >)* >  | < DIGIT : [ "0"-"9" ] >| < IDENT : < LETTER > ( < LETTER > | < DIGIT > )* >| < STRING : "\"" ( " " | < LETTER > | < DIGIT > | < OTHERCHAR > )* "\"" >| < LETTER : ["a"-"z", "A"-"Z", "_" ] >| < OTHERCHAR : [ "+", "-", "*", "/", ".", ",", ";", ":", "!", "?", "=", "#", "%", "<", ">", "$", "(", ")", "[", "]", "{", "}", "@", "&", "^", "|", "\\" ] >}/* Expressions */void LITERAL():{}{	< TRUE > | < FALSE > | < NUMBER > }void SELECTOR() :{}{  < LBRACKET > EXPR() < RBRACKET > [ SELECTOR() ]}void ARRAYLEN() :{}{  < BLANK > < IDENT > [ SELECTOR() ]}void PRIMARYEXPR() :{}{  LITERAL() | < LPAR > EXPR() < RPAR > | LOOKAHEAD(2) PROCEDURECALL()  | < IDENT > [ SELECTOR() ] | ARRAYLEN()}void UNARYEXPR() :{}{  [ < ADDOP > ] PRIMARYEXPR()}void MULEXPR() :{}{  UNARYEXPR() ( < MULOP > UNARYEXPR() )*}void ADDEXPR() :{}{  MULEXPR()( < ADDOP > MULEXPR() )*}void RELEXPR() :{}{  ADDEXPR() [ < RELOP > ADDEXPR() ]}void EQUALEXPR() :{}{  RELEXPR() [ < EQUALOP > RELEXPR() ]}void CONDANDEXPR() :{}{  EQUALEXPR()( < AND > EQUALEXPR() )*}void CREATIONEXPR() :{}{  < NEW > PRIMTYPE() < LBRACKET > EXPR() < RBRACKET >  ( < LBRACKET > EXPR() < RBRACKET > )*}void EXPR() :{}{  CONDANDEXPR() ( < OR > CONDANDEXPR() )* | CREATIONEXPR()}void ARGUMENTLIST() :{}{  EXPR() ( < COMMA > EXPR() )*}void PROCEDURECALL() :{}{ 	< IDENT > < LPAR > [ ARGUMENTLIST() ] < RPAR >}void ASSIGNMENT() :{}{  < IDENT > [ SELECTOR() ] ":=" EXPR()    }void IFSTATEMENT() :{}{  < IF > EXPR() < THEN > STATEMENTLIST() [ < ELSE > STATEMENTLIST() ] < ENDIF >}void WHILESTATEMENT() :{}{  < WHILE > EXPR() < DO > STATEMENTLIST() < ENDWHILE >}void RETURNSTATEMENT() :{}{  < RETURN > [ EXPR()]}void WRITESTATEMENT() :{}{  < WRITE > < STRING >}void STATEMENT() :{}{  IFSTATEMENT()| WHILESTATEMENT()| RETURNSTATEMENT()| WRITESTATEMENT()| LOOKAHEAD(2) ASSIGNMENT()| PROCEDURECALL()| BLOCK()}void STATEMENTLIST() :{}{  ( STATEMENT() < SEMICOLON > )*}void BLOCK() :{}{  [ DECL() ] < BEGIN > STATEMENTLIST() < END >}void PRIMTYPE() :{}{  < INTEGER > | < BOOLEAN >}void TYPE() :{}{  PRIMTYPE() ( < LBRACKET > < RBRACKET >)*}void RETURNTYPE() :{}{  < VOID > | TYPE() }void CONSTDECL() :{}{  < CONST > < IDENT > < IS > LITERAL() < SEMICOLON >}void VARDECL() :{}{   TYPE() < IDENT > (< COMMA > < IDENT >)* < SEMICOLON >}void DECL() :{}{  < DECLARE > ( CONSTDECL() | VARDECL() )*}void FORMALPARAM() :{}{  [ < READONLY > ] TYPE() < IDENT >}void FORMALPARAMLIST() :{}{  FORMALPARAM()( < COMMA > FORMALPARAM() )*}void PROCEDURE() :{}{  < PROCEDURE > RETURNTYPE() < IDENT > < LPAR > [ FORMALPARAMLIST() ] < RPAR > BLOCK() < IDENT > < SEMICOLON >}void PROGRAM() :{Token t;}{    < PROGRAM > t = < IDENT >  {program_name = t.image;}  ( DECL() | PROCEDURE() )*  < BEGIN > STATEMENTLIST() < END > < IDENT > < DOT >}/** Root node for production */void Start() :{}{ PROGRAM()}
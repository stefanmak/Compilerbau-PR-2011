options{  JDK_VERSION = "1.5";}PARSER_BEGIN(StefanMak)import yapl.interfaces.*;import yapl.lib.*;/** Simple brace matcher. */public class StefanMak{  /** Main entry point. */  public static void main(String args []) throws ParseException, TokenMgrError  {    StefanMak parser = new StefanMak(System.in);    System.out.println("Start Eingabe");	try	    {	      parser.Start();	      	    }	    catch (TokenMgrError ex)	    {	      //CompilerMessage.printError(ex,"test");	    }	    catch (ParseException ex)	    {	      //CompilerMessage.printError(ex,"test");	    }		    	  }}PARSER_END(StefanMak)SKIP :{  " "| "\r"| "\t"| "\n"}/* for comments - not necessary nested */SPECIAL_TOKEN : {    < COMMENT : "/*" ( ~[ "*" ] | "*" ~[ "/" ] )* "*/" >}TOKEN : /* Elementary Words to provide warnings*/{  < LPAR : "(" >| < RPAR : ")" >| < LBRACKET : "[" >| < RBRACKET : "]" >| < COMMA : "," >| < SEMICOLON : ";" >| < IS : "=" >| < SET : ":=" >| < DOT : "." >| < COLON : ":" >| < CALLSIGN : "!" >| < QUESTIONMARK : "?" >| < IF : "If" >| < ENDIF : "EndIf" >| < THEN : "Then" >| < ELSE : "Else" >| < OR : "Or" >| < VOID : "void" >| < AND : "And" >| < TRUE : "True" >| < FALSE : "False" >| < WHILE : "While" >| < ENDWHILE : "EndWhile" >| < DO : "Do" >| < RETURN : "Return" >| < WRITE : "Write" >| < BEGIN : "Begin" >| < END : "End" >| < PROCEDURE : "Procedure" >| < PROGRAM : "Program" >| < INTEGER : "Integer" >| < BOOLEAN : "Boolean" >| < CONST : "Const" >| < DECLARE : "Declare" >| < READONLY : "Readonly" >| < NEW : "new" >| < BLANK : "#" >| < WRITEINT : "writeint" >| < WRITEBOOL : "writebool" >| < WRITELN : "writeln" >| < READINT : "readint" >}TOKEN : /* Basic Elements*/{  < LETTER : [ "a"-"z", "A"-"Z", "_" ] >| < DIGIT : [ "0"-"9" ] >| < OTHERCHAR : [ "+", "-", "*", "/", ".", ",", ";", ":", "!", "?", "=", "#", "%", "<", ">", "$", "(", ")", "[", "]", "{", "}", "@", "&", "^", "|", "\\" ] >| < IDENT :    < LETTER > ( < LETTER > | < DIGIT > )* >| < NUMBER : < DIGIT > (< DIGIT >)* >| < STRING :    "\"" ( " " | < LETTER > | < DIGIT > | < OTHERCHAR > )* "\"" >}TOKEN : /* Operations */{  < RELOP : "<" | "<=" | ">=" | ">" >| < EQUALOP : "==" | "!=" >| < ADDOP : "+" | "-" >| < MULOP : "*" | "/" | "%" >}/* Expressions */void LITERAL():{}{	< TRUE > | < FALSE > | < NUMBER > }void SELECTOR() :{}{  < LBRACKET > EXPR() < RBRACKET > [ SELECTOR() ]}void ARRAYLEN() :{}{  < BLANK > < IDENT > [ SELECTOR() ]}void PRIMARYEXPR() :{}{  LITERAL()| "(" EXPR() ")"| LOOKAHEAD(2)  PROCEDURECALL()| < IDENT > [ SELECTOR() ]| ARRAYLEN()}void UNARYEXPR() :{}{  [ < ADDOP > ] PRIMARYEXPR()}void MULEXPR() :{}{  UNARYEXPR()  (    < MULOP > UNARYEXPR()  )*}void ADDEXPR() :{}{  MULEXPR()  (    < ADDOP > MULEXPR()  )*}void RELEXPR() :{}{  ADDEXPR() [ < RELOP > ADDEXPR() ]}void EQUALEXPR() :{}{  RELEXPR() [ < EQUALOP > RELEXPR() ]}void CONDANDEXPR() :{}{  EQUALEXPR()  (    < AND > EQUALEXPR()  )*}void CREATIONEXPR() :{}{  < NEW > PRIMTYPE() "[" EXPR() "]"  (    < LBRACKET > EXPR() < RBRACKET >  )*}void EXPR() :{}{  CONDANDEXPR()  (    < OR > CONDANDEXPR()  )*| CREATIONEXPR()}void ARGUMENTLIST() :{}{  EXPR() ( < COMMA > EXPR() )*}void PROCEDURECALL() :{}{ 	< IDENT > <LPAR > [ ARGUMENTLIST() ] < RPAR >}void ASSIGNMENT() :{}{  < IDENT > [ SELECTOR() ] ":=" EXPR()    }void IFSTATEMENT() :{}{  "If" EXPR() "Then" STATEMENTLIST() [ "Else" STATEMENTLIST() ] "EndIf"}void WHILESTATEMENT() :{}{  "While" EXPR() "Do" STATEMENTLIST() "EndWhile"}void RETURNSTATEMENT() :{}{  "Return" EXPR()}void WRITESTATEMENT() :{}{  "Write" < STRING >}void STATEMENT() :{}{  IFSTATEMENT()| WHILESTATEMENT()| RETURNSTATEMENT()| WRITESTATEMENT()| LOOKAHEAD(2) ASSIGNMENT()| PROCEDURECALL()| BLOCK()}void STATEMENTLIST() :{}{  (    STATEMENT() ";"  )*}void BLOCK() :{}{  [ DECL() ] "Begin" STATEMENTLIST() "End"}void PRIMTYPE() :{}{  "Integer"| "Boolean"}void TYPE() :{}{  PRIMTYPE() ("[" "]")*}void RETURNTYPE() :{}{  < VOID >| TYPE()}void CONSTDECL() :{}{  "Const" < IDENT > "=" LITERAL() ";"}void VARDECL() :{}{  < IDENT > ("," < IDENT >)* ":" TYPE() ";"}void DECL() :{}{  "Declare"  (    CONSTDECL()  | VARDECL()  )*}void FORMALPARAM() :{}{  [ < READONLY > ] TYPE() < IDENT >}void FORMALPARAMLIST() :{}{  FORMALPARAM()  (    < COMMA > FORMALPARAM()  )*}void PROCEDURE() :{}{  "Procedure" RETURNTYPE() < IDENT > "(" [ FORMALPARAMLIST() ] ")" BLOCK() < IDENT > ";"}void PROGRAM() :{}{  "Program" < IDENT >  (    DECL()  | PROCEDURE()  )*  "Begin" STATEMENTLIST() "End" < IDENT > "."}/** Root production. */void Start() :{  Token t;}{  {    do    {      t = getNextToken();      System.out.println(t.toString());    }    while (t.kind != EOF);  }  < EOF >}
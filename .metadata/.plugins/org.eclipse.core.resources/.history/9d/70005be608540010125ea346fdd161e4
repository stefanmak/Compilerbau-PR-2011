options{  JDK_VERSION = "1.5";}PARSER_BEGIN(StefanMak)import yapl.interfaces.*;import yapl.lib.*;import java.io.FileInputStream;import java.io.File;import java.io.IOException;/** Simple brace matcher. */public class StefanMak{  /* Program Name for failure and debugging*/	  private static String program_name;    /** Main entry point. */  public static void main(String args []) throws ParseException, TokenMgrError  {	/* Declare variables for program read*/	File file = null;	FileInputStream fis = null;		/* Read YAPL File from file */	if(args.length != 0)	{		try		{	    			file = new File(args[0]);			fis = new FileInputStream(file);		}catch(IOException ex)		{		  System.err.println(ex);		}	}else	{	  System.out.println("YAPL Program as first parameter needed...");	  System.out.println("System exit...");	  System.exit(0);	}		    StefanMak parser = new StefanMak(fis);    	try	    {	      parser.Start();	      	    }	    catch (TokenMgrError ex)	    {	      ex.printStackTrace();	      //CompilerMessage.printError(ex,"test");	    }	    catch (ParseException ex)	    {	      ex.printStackTrace();	      //CompilerMessage.printError(ex,"test");	    }		    	  }}PARSER_END(StefanMak)SKIP :{  " "| "\r"| "\t"| "\n"}SPECIAL_TOKEN : /* for comments - not necessary nested */{    < COMMENT : "/*" ( ~[ "*" ] | "*" ~[ "/" ] )* "*/" >}TOKEN : /* Elementary Words to provide warnings*/{  < LPAR : "(" >| < RPAR : ")" >| < LBRACKET : "[" >| < RBRACKET : "]" >| < COMMA : "," >| < SEMICOLON : ";" >| < DOT : "." >| < IS : "=" >| < COLON : ":" >| < IF : "If" >| < ENDIF : "EndIf" >| < THEN : "Then" >| < ELSE : "Else" >| < OR : "Or" >| < VOID : "void" >| < AND : "And" >| < TRUE : "True" >| < FALSE : "False" >| < WHILE : "While" >| < ENDWHILE : "EndWhile" >| < DO : "Do" >| < RETURN : "Return" >| < WRITE : "Write" >| < BEGIN : "Begin" >| < END : "End" >| < PROCEDURE : "Procedure" >| < PROGRAM : "Program" >| < INTEGER : "int" >| < BOOLEAN : "bool" >| < CONST : "Const" >| < DECLARE : "Declare" >| < READONLY : "readonly" >| < NEW : "new" >| < BLANK : "#" >} TOKEN : /* Basic Elements*/{  < LETTER : [ "a"-"z", "A"-"Z", "_" ] >| < DIGIT : [ "0"-"9" ] >| < OTHERCHAR : [ "+", "-", "*", "/", ".", ",", ";", ":", "!", "?", "=", "#", "%", "<", ">", "$", "(", ")", "[", "]", "{", "}", "@", "&", "^", "|", "\\" ] >| < IDENT :  < LETTER > ( < LETTER > | < DIGIT > )* >| < NUMBER : < DIGIT > (< DIGIT >)* >| < STRING : "\"" ( " " | < LETTER > | < DIGIT > | < OTHERCHAR > )* "\"" >}TOKEN : /* Operations */{  < RELOP : "<" | "<=" | ">=" | ">" >| < EQUALOP : "==" | "!=" >| < ADDOP : "+" | "-" >| < MULOP : "*" | "/" | "%" >}/* Expressions */void LITERAL():{}{	< TRUE > | < FALSE > | < NUMBER > }void SELECTOR() :{}{  < LBRACKET > EXPR() < RBRACKET > [ SELECTOR() ]}void ARRAYLEN() :{}{  < BLANK > < IDENT > [ SELECTOR() ]}void PRIMARYEXPR() :{}{  LITERAL()| < LPAR > EXPR() < RPAR >| LOOKAHEAD(2)  PROCEDURECALL()| < IDENT > [ SELECTOR() ]| ARRAYLEN()}void UNARYEXPR() :{}{  [ < ADDOP > ] PRIMARYEXPR()}void MULEXPR() :{}{  UNARYEXPR()  (    < MULOP > UNARYEXPR()  )*}void ADDEXPR() :{}{  MULEXPR()  (    < ADDOP > MULEXPR()  )*}void RELEXPR() :{}{  ADDEXPR() [ < RELOP > ADDEXPR() ]}void EQUALEXPR() :{}{  RELEXPR() [ < EQUALOP > RELEXPR() ]}void CONDANDEXPR() :{}{  EQUALEXPR()  (    < AND > EQUALEXPR()  )*}void CREATIONEXPR() :{}{  < NEW > PRIMTYPE() < LBRACKET > EXPR() < RBRACKET >  (    < LBRACKET > EXPR() < RBRACKET >  )*}void EXPR() :{}{  CONDANDEXPR() ( < OR > CONDANDEXPR() )* | CREATIONEXPR()}void ARGUMENTLIST() :{}{  EXPR() ( < COMMA > EXPR() )*}void PROCEDURECALL() :{}{ 	< IDENT > <LPAR > [ ARGUMENTLIST() ] < RPAR >}void ASSIGNMENT() :{}{  < IDENT > [ SELECTOR() ] ":=" EXPR()    }void IFSTATEMENT() :{}{  < IF > EXPR() < THEN > STATEMENTLIST() [ < ELSE > STATEMENTLIST() ] < ENDIF >}void WHILESTATEMENT() :{}{  < WHILE > EXPR() < DO > STATEMENTLIST() < ENDWHILE >}void RETURNSTATEMENT() :{}{  < RETURN > EXPR()}void WRITESTATEMENT() :{}{  < WRITE > < STRING >}void STATEMENT() :{}{  IFSTATEMENT()| WHILESTATEMENT()| RETURNSTATEMENT()| WRITESTATEMENT()| LOOKAHEAD(2) ASSIGNMENT()| PROCEDURECALL()| BLOCK()}void STATEMENTLIST() :{}{  (    STATEMENT() < SEMICOLON >  )*}void BLOCK() :{}{  [ DECL() ] < BEGIN > STATEMENTLIST() < END >}void PRIMTYPE() :{}{  < INTEGER >| < BOOLEAN >}void TYPE() :{}{  PRIMTYPE() ( < LBRACKET > < RBRACKET >)*}void RETURNTYPE() :{}{  < VOID > | TYPE()}void CONSTDECL() :{}{  < CONST > < IDENT > < IS > LITERAL() < SEMICOLON >}void VARDECL() :{}{  < IDENT > (< COMMA > < IDENT >)* < COLON > TYPE() < SEMICOLON >}void DECL() :{}{  < DECLARE > ( CONSTDECL() | VARDECL() )*}void FORMALPARAM() :{}{  [ < READONLY > ] TYPE() < IDENT >}void FORMALPARAMLIST() :{}{  FORMALPARAM()( < COMMA > FORMALPARAM() )*}void PROCEDURE() :{}{  < PROCEDURE > RETURNTYPE() < IDENT > < LPAR > [ FORMALPARAMLIST() ] < RPAR > BLOCK() < IDENT > < SEMICOLON >}void PROGRAM() :{Token t;}{    < PROGRAM > t = < IDENT >  {program_name = t.image;}  ( DECL() | PROCEDURE() )*  < BEGIN > STATEMENTLIST() < END > < IDENT > < DOT >}/** Root production. */void Start() :{}{ PROGRAM()}
options{  JDK_VERSION = "1.5";}PARSER_BEGIN(StefanMak)/** Simple brace matcher. */public class StefanMak{  /** Main entry point. */  public static void main(String args []) throws ParseException  {    StefanMak parser = new StefanMak(System.in);    System.out.println("Start Eingabe");    parser.Input();  }}PARSER_END(StefanMak)TOKEN : /* Basic Elements*/{  < LETTER : [ "a"-"z", "A"-"Z", "_" ] >| < DIGIT : [ "0"-"9" ] >| < OTHERCHAR : [ "+", "-", "*", "/", ".", ",", ";", ":", "!", "?", "=", "#", "%", "<", ">", "$", "(", ")", "[", "]", "{", "}", "@", "&", "^", "|", "\\" ] >| < IDENT : < LETTER > (< LETTER > | < DIGIT > )* >| < NUMBER : < DIGIT > (< DIGIT >) >| < STRING : "\"" ( " " | < LETTER > | < DIGIT > | < OTHERCHAR >) "\"" > }TOKEN : /* Operations */{  < RELOP : "<" | "<=" | ">=" | ">" >| < EQUALOP : "==" | "!=" >| < ADDOP : "+" | "-" >| < MULOP : "*" | "/" | "%" >    }TOKEN : /* Expressions */{  < LITERAL : "True" | "False" | < NUMBER > >}/* Basic Expressions */void SELECTOR() :{}{  "[" EXPR() "]" [ SELECTOR() ]}void ARRAYLEN() :{}{  "#" < IDENT > [ SELECTOR() ]}void PRIMARYEXPR() :{}{  < LITERAL > | "(" EXPR() ")" | PROCEDURECALL() | < IDENT > [ SELECTOR() ] | ARRAYLEN()   }void UNARYEXPR() :{}{  [ < ADDOP > ] PRIMARYEXPR()}void MULEXPR() :{}{  UNARYEXPR() ( < MULOP > UNARYEXPR() )*}void ADDEXPR() :{}{  MULEXPR() ( < ADDOP > MULEXPR() )*}void RELEXPR() :{}{  ADDEXPR() [ < RELOP > ADDEXPR() ]}void EQUALEXPR() :{}{  RELEXPR() [ < EQUALOP > RELEXPR() ]}void CONDANDEXPR() :{}{  EQUALEXPR()( "And" EQUALEXPR() )*}void CREATIONEXPR() :{}{  "new" PRIMTYPE() "[" EXPR() "]" ( "[" EXPR() "]" )*}void EXPR() :{}{  CONDANDEXPR()  (    "Or" CONDANDEXPR()  )*| CREATIONEXPR()}void ARGUMENTLIST() :{}{  EXPR()( "," EXPR() )*}void PROCEDURECALL() :{}{  < IDENT > "(" [ ARGUMENTLIST() ] ")"}void ASSIGNMENT() :{}{  < IDENT > [ SELECTOR() ] ":=" EXPR()}void IFSTATEMENT() :{}{  "If" EXPR() "Then" STATEMENTLIST() [ "Else" STATEMENTLIST() ] "EndIf"}void WHILESTATEMENT() :{}{  "While" EXPR() "Do" STATEMENTLIST() "EndWhile"}void RETURN_STATEMENT() :{}{  "Return" EXPR()}void WRITE_STATEMENT() :{}{  "Write" < STRING >}void PRIMTYPE() :{}{  "test"}/** Root production. */void Input() :{}{  MatchedBraces()  (    "\n"  | "\r"  )*  < EOF >}/** Brace matching production. */void MatchedBraces() :{}{  "{" [ MatchedBraces() ] "}"}
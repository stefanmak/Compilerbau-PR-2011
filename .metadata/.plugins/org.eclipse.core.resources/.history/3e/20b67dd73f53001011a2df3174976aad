options{  JDK_VERSION = "1.5";}PARSER_BEGIN(StefanMak)/** Simple brace matcher. */public class StefanMak{  /** Main entry point. */  public static void main(String args []) throws ParseException  {    StefanMak parser = new StefanMak(System.in);    System.out.println("Start Eingabe");    parser.Start();  }}PARSER_END(StefanMak)TOKEN : /* Basic Elements*/{  < LETTER : [ "a"-"z", "A"-"Z", "_" ] >| < DIGIT : [ "0"-"9" ] >| < OTHERCHAR : [ "+", "-", "*", "/", ".", ",", ";", ":", "!", "?", "=", "#", "%", "<", ">", "$", "(", ")", "[", "]", "{", "}", "@", "&", "^", "|", "\\" ] >| < IDENT :    < LETTER >    (      < LETTER >    | < DIGIT >    )* >| < NUMBER : < DIGIT > (< DIGIT >) >| < STRING :    "\""    (      " "    | < LETTER >    | < DIGIT >    | < OTHERCHAR >    )    "\"" >}TOKEN : /* Operations */{  < RELOP :    "<"  | "<="  | ">="  | ">" >| < EQUALOP :    "=="  | "!=" >| < ADDOP :    "+"  | "-" >| < MULOP :    "*"  | "/"  | "%" >}TOKEN : /* Expressions */{  < LITERAL :    "True"  | "False"  | < NUMBER > >}/* Basic Expressions */void SELECTOR() :{}{  "[" EXPR() "]" [ SELECTOR() ]}void ARRAYLEN() :{}{  "#" < IDENT > [ SELECTOR() ]}void PRIMARYEXPR() :{}{  < LITERAL >| "(" EXPR() ")"| PROCEDURECALL()| < IDENT > [ SELECTOR() ]| ARRAYLEN()}void UNARYEXPR() :{}{  [ < ADDOP > ] PRIMARYEXPR()}void MULEXPR() :{}{  UNARYEXPR()  (    < MULOP > UNARYEXPR()  )*}void ADDEXPR() :{}{  MULEXPR()  (    < ADDOP > MULEXPR()  )*}void RELEXPR() :{}{  ADDEXPR() [ < RELOP > ADDEXPR() ]}void EXPR():{}{  "test"}void PROCEDURECALL():{}{  "test"}/** Root production. */void Start() :{  Token t;}{  {    do    {      t = getNextToken();      System.out.println(t.toString());    }    while (t.kind != EOF);  }  < EOF >}
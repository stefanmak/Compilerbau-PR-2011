options{  JDK_VERSION = "1.5";}PARSER_BEGIN(StefanMak)/** Simple brace matcher. */public class StefanMak{  /** Main entry point. */  public static void main(String args []) throws ParseException  {    StefanMak parser = new StefanMak(System.in);    System.out.println("Start Eingabe");    parser.Input();  }}PARSER_END(StefanMak)TOKEN : /* Basic Elements*/{  < LETTER : [ "a"-"z", "A"-"Z", "_" ] >| < DIGIT : [ "0"-"9" ] >| < OTHERCHAR : [ "+", "-", "*", "/", ".", ",", ";", ":", "!", "?", "=", "#", "%", "<", ">", "$", "(", ")", "[", "]", "{", "}", "@", "&", "^", "|", "\\" ] >| < IDENT : < LETTER > (< LETTER > | < DIGIT > )* >| < NUMBER : < DIGIT > (< DIGIT >) >| < STRING : "\"" ( " " | < LETTER > | < DIGIT > | < OTHERCHAR >) "\"" > }TOKEN : /* Operations */{  < REALOP : "<" | "<=" | ">=" | ">" >| < EQUALOP : "==" | "!=" >| < ADDOP : "+" | "-" >| < MULOP : "*" | "/" | "%" >    }TOKEN : /* Expressions */{  < LITERAL : "True" | "False" | < NUMBER > >}/* Basic Expressions */void SELECTOR() :{}{  "[" EXPR() "]" [ SELECTOR() ]}void ARRAYLEN() :{}{  "#" < IDENT > [ SELECTOR() ]}void PRIMARYEXPR() :{}{  < LITERAL > | "(" EXPR() ")" | PROCEDURECALL() | < IDENT > [ SELECTOR() ] | ARRAYLEN()   }void UNARYEXPR() :{}{  [ < ADDOP > ] PRIMARYEXPR()}void MULEXPR() :{}{  UNARYEXPR() ( < MULOP > UNARYEXPR() )*}void ADDEXPR() :{}{  MULEXPR() ( < ADDOP > MULEXPR() )*}void REL_EXPR() :{}{  ADD_EXPR() [ < RELOP > ADD_EXPR() ]}void EXPR() :{}{   "#" < IDENT > [ SELECTOR() ]}void PROCEDURECALL() :{}{   "#" < IDENT > [ SELECTOR() ]}/** Root production. */void Input() :{}{  MatchedBraces()  (    "\n"  | "\r"  )*  < EOF >}/** Brace matching production. */void MatchedBraces() :{}{  "{" [ MatchedBraces() ] "}"}
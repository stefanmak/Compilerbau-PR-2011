options{  JDK_VERSION = "1.5";}PARSER_BEGIN(StefanMak)/** Simple brace matcher. */public class StefanMak{  /** Main entry point. */  public static void main(String args []) throws ParseException  {    StefanMak parser = new StefanMak(System.in);    System.out.println("Start Eingabe");    parser.Start();  }}PARSER_END(StefanMak)TOKEN : /* Basic Elements*/{  < LETTER : [ "a"-"z", "A"-"Z", "_" ] >| < DIGIT : [ "0"-"9" ] >| < OTHERCHAR : [ "+", "-", "*", "/", ".", ",", ";", ":", "!", "?", "=", "#", "%", "<", ">", "$", "(", ")", "[", "]", "{", "}", "@", "&", "^", "|", "\\" ] >| < IDENT :    < LETTER >    (      < LETTER >    | < DIGIT >    )* >| < NUMBER : < DIGIT > (< DIGIT >) >| < STRING :    "\""    (      " "    | < LETTER >    | < DIGIT >    | < OTHERCHAR >    )    "\"" >  | < COMMA : ",">}TOKEN : /* Operations */{  < RELOP :    "<"  | "<="  | ">="  | ">" >| < EQUALOP :    "=="  | "!=" >| < ADDOP :    "+"  | "-" >| < MULOP :    "*"  | "/"  | "%" >}TOKEN : /* Expressions */{  < LITERAL :    "True"  | "False"  | < NUMBER > >}/* Basic Expressions */void SELECTOR() :{}{  "[" EXPR() "]" [ SELECTOR() ]}void ARRAYLEN() :{}{  "#" < IDENT > [ SELECTOR() ]}void PRIMARYEXPR() :{}{  < LITERAL >| "(" EXPR() ")"| PROCEDURECALL()| < IDENT > [ SELECTOR() ]| ARRAYLEN()}void UNARYEXPR() :{}{  [ < ADDOP > ] PRIMARYEXPR()}void MULEXPR() :{}{  UNARYEXPR()  (    < MULOP > UNARYEXPR()  )*}void ADDEXPR() :{}{  MULEXPR()  (    < ADDOP > MULEXPR()  )*}void RELEXPR() :{}{  ADDEXPR() [ < RELOP > ADDEXPR() ]}void EQUALEXPR() :{}{  RELEXPR() [ < EQUALOP > RELEXPR() ]}void CONDANDEXPR() :{}{  EQUALEXPR()  (    "And" EQUALEXPR()  )*}void CREATIONEXPR() :{}{  "new" PRIMTYPE() "[" EXPR() "]"  (    "[" EXPR() "]"  )*}void EXPR() :{}{  CONDANDEXPR()  (    "Or" CONDANDEXPR()  )*| CREATIONEXPR()}void ARGUMENTLIST() :{}{  EXPR() ( < COMMA > EXPR() )*}void PROCEDURECALL() :{}{ 	< IDENT > "(" [ ARGUMENTLIST() ] ")"}void ASSIGNMENT() :{}{  < IDENT > [ SELECTOR() ] ":=" EXPR()    }void IFSTATEMENT() :{}{  "If" EXPR() "Then" STATEMENTLIST() [ "Else" STATEMENTLIST() ] "EndIf"}void WHILESTATEMENT() :{}{  "While" EXPR() "Do" STATEMENTLIST() "EndWhile"}void RETURNSTATEMENT() :{}{  "Return" EXPR()}void WRITESTATEMENT() :{}{  "Write" < STRING >}void STATEMENT() :{}{  IFSTATEMENT()| WHILESTATEMENT()| RETURNSTATEMENT()| WRITESTATEMENT()| ASSIGNMENT()| PROCEDURECALL()| BLOCK()}void STATEMENTLIST() :{}{  (    STATEMENT() ";"  )*}void BLOCK() :{}{  [ DECL() ] "Begin" STATEMENTLIST() "End"}void PRIMTYPE() :{}{  "Integer"| "Boolean"}void TYPE() :{}{  PRIMTYPE() ("[" "]")*}void RETURNTYPE() :{}{  "void"| TYPE()}void CONSTDECL() :{}{  "Const" < IDENT > "=" < LITERAL > ";"}void VARDECL() :{}{  < IDENT > ("," < IDENT >)* ":" TYPE() ";"}void DECL() :{}{  "Declare"  (    CONSTDECL()  | VARDECL()  )*}void FORMALPARAM() :{}{  [ "readonly" ] TYPE() < IDENT >}void FORMALPARAMLIST() :{}{  FORMALPARAM()  (    "," FORMALPARAM()  )*}void PROCEDURE() :{}{  "Procedure" RETURNTYPE() < IDENT > "(" [ FORMALPARAMLIST() ] ")" BLOCK() < IDENT > ";"}void PROGRAM() :{}{  "Program" < IDENT >  (    DECL()  | PROCEDURE()  )*  "Begin" STATEMENTLIST() "End" < IDENT > "."}/** Root production. */void Start() :{  Token t;}{  {    do    {      t = getNextToken();      System.out.println(t.toString());    }    while (t.kind != EOF);  }  < EOF >}
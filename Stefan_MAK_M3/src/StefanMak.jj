 /** * Compiler of STEFAN MAK * options where taken from the example file generated by JavaCC */options{  JDK_VERSION = "1.5";  static = true;}PARSER_BEGIN(StefanMak)import yapl.interfaces.*;import yapl.lib.*;import yapl.impl.*;import java.io.FileInputStream;import java.io.File;import java.io.IOException;/** Scanner for Compiler Milestone 1 */public class StefanMak{  /** Program Name for failure and debugging*/  private static String program_name;  /** Symbol Table */  private static SymboltableImpl symTable;  /** Declare predefined prcedures as symbols */  private static Symbol pre_writeln;  private static Symbol pre_writeint;  private static Symbol pre_writebool;  private static Symbol pre_readint;  /** List for var_decl */  //public LinkedList<Symbol> varList = new LinkedList<Symbol>();  /** Main entry point. */  public static void main(String args []) throws TokenMgrError, YAPLException, ParseException  {    /** Declare variables for program read*/    File file = null;    FileInputStream fis = null;    symTable = new SymboltableImpl();    /** Read YAPL File from file */    if (args.length != 0)    {      try      {        file = new File(args [0]);        fis = new FileInputStream(file);      }      catch (IOException ex)      {        System.err.println(ex);      }    }    else    {      System.out.println("YAPL Program as first parameter needed...");      System.out.println("System exit...");      System.exit(0);    }    /** Create new Symbol Table */    /** Give my Parser the InputStream to start the work */    StefanMak parser = new StefanMak(fis);    try    {      parser.Start();      /** Parsing was correct and complete */      CompilerMessage.printOK(StefanMak.program_name);    }    catch (TokenMgrError ex)    {      /** Lexical Error etc. occured */      CompilerMessage.printError(ex, StefanMak.program_name);    }    catch (ParseException ex)    {      /** Parse Error occured */      CompilerMessage.printError(ex, StefanMak.program_name);    }    catch (YAPLException ex)    {      /** SymbolTable Error occured */      CompilerMessage.printError(ex, StefanMak.program_name);    }  }}PARSER_END(StefanMak)/** Skip NewLines etc. by parsing... (taken from example)*/SKIP :{  " "| "\r"| "\t"| "\n"}SPECIAL_TOKEN : /* for comments - not necessary nested!*//* (~[ ])* *//* Didn`t work on Test07 at Milestone2 */{  < COMMENT :    "/*"    (      ~[ "*" ]    | "*" ~[ "/" ]    )*    "*/" >}TOKEN : /* Elementary Words/Characters to prevent warnings*/{  < LPAR : "(" >| < RPAR : ")" >| < LBRACKET : "[" >| < RBRACKET : "]" >| < COMMA : "," >| < SEMICOLON : ";" >| < DOT : "." >| < IS : "=" >| < COLON : ":" >| < IF : "If" >| < ENDIF : "EndIf" >| < THEN : "Then" >| < ELSE : "Else" >| < OR : "Or" >| < VOID : "void" >| < AND : "And" >| < TRUE : "True" >| < FALSE : "False" >| < WHILE : "While" >| < ENDWHILE : "EndWhile" >| < DO : "Do" >| < RETURN : "Return" >| < WRITE : "Write" >| < BEGIN : "Begin" >| < END : "End" >| < PROCEDURE : "Procedure" >| < PROGRAM : "Program" >| < INTEGER : "int" >| < BOOLEAN : "bool" >| < CONST : "Const" >| < DECLARE : "Declare" >| < READONLY : "readonly" >| < NEW : "new" >| < BLANK : "#" >}TOKEN : /* Operations */{  < RELOP :    "<"  | "<="  | ">="  | ">" >| < EQUALOP :    "=="  | "!=" >| < ADDOP :    "+"  | "-" >| < MULOP :    "*"  | "/"  | "%" >}TOKEN : /* Basic Elements*/{  < NUMBER : < DIGIT > (< DIGIT >)* >| < DIGIT : [ "0"-"9" ] >| < IDENT :    < LETTER >    (      < LETTER >    | < DIGIT >    )* >| < STRING :    "\""    (      " "    | < LETTER >    | < DIGIT >    | < OTHERCHAR >    )*    "\"" >| < LETTER : [ "a"-"z", "A"-"Z", "_" ] >| < OTHERCHAR : [ "+", "-", "*", "/", ".", ",", ";", ":", "!", "?", "=", "#", "%", "<", ">", "$", "(", ")", "[", "]", "{", "}", "@", "&", "^", "|", "\\" ] >}/* Expressions */Token LITERAL() :{  Token t;}{  t = < TRUE >| t = < FALSE >| t = < NUMBER >  {    return t;  }}void SELECTOR() :{}{  < LBRACKET > EXPR() < RBRACKET > [ SELECTOR() ]}void ARRAYLEN() :{  Token t;}{  < BLANK > t = < IDENT > [ SELECTOR() ]  {    Symbol ident = symTable.lookup(t.image);    if (ident != null && (ident.getKind() != Symbol.Variable && ident.getKind() != Symbol.Parameter))    {      // wrong type not an array      throw new YAPLException(CompilerError.SymbolIllegalUse, ident, t);    }    else if (ident == null)    {      // Array not declared      throw new YAPLException(CompilerError.IdentNotDecl, ident, t);    }  }}void PRIMARYEXPR() :{  Token t;}{  LITERAL()| < LPAR > EXPR() < RPAR >| LOOKAHEAD(2)  PROCEDURECALL()| t = < IDENT > [ SELECTOR() ]  {    Symbol ident = symTable.lookup(t.image);    if (ident != null && (ident.getKind() == Symbol.Procedure || ident.getKind() == Symbol.Program))    {      // wrong type      throw new YAPLException(CompilerError.SymbolIllegalUse, ident, t);    }    else if (ident == null)    {      // variable not declared      throw new YAPLException(CompilerError.IdentNotDecl, ident, t);    }  }| ARRAYLEN()}void UNARYEXPR() :{}{  [ < ADDOP > ] PRIMARYEXPR()}void MULEXPR() :{}{  UNARYEXPR()  (    < MULOP > UNARYEXPR()  )*}void ADDEXPR() :{}{  MULEXPR()  (    < ADDOP > MULEXPR()  )*}void RELEXPR() :{}{  ADDEXPR() [ < RELOP > ADDEXPR() ]}void EQUALEXPR() :{}{  RELEXPR() [ < EQUALOP > RELEXPR() ]}void CONDANDEXPR() :{}{  EQUALEXPR()  (    < AND > EQUALEXPR()  )*}void CREATIONEXPR() :{}{  < NEW > PRIMTYPE() < LBRACKET > EXPR() < RBRACKET >  (    < LBRACKET > EXPR() < RBRACKET >  )*}void EXPR() :{}{  CONDANDEXPR()  (    < OR > CONDANDEXPR()  )*| CREATIONEXPR()}void ARGUMENTLIST() :{}{  EXPR()  (    < COMMA > EXPR()  )*}void PROCEDURECALL() :{  Token t;}{  t = < IDENT > < LPAR > [ ARGUMENTLIST() ] < RPAR >  {    Symbol ident = symTable.lookup(t.image);    if (ident != null && (ident.getKind() != Symbol.Procedure))    {      // wrong type not an array      throw new YAPLException(CompilerError.SymbolIllegalUse, ident, t);    }    else if (ident == null)    {      // Array not declared      throw new YAPLException(CompilerError.IdentNotDecl, ident, t);    }  }}void ASSIGNMENT() :{  Token t;}{  t = < IDENT > [ SELECTOR() ] ":=" EXPR()  {    Symbol assi = symTable.lookup(t.image);    int kind;    if (assi != null) kind = assi.getKind();    else throw new YAPLException(CompilerError.IdentNotDecl, assi, t);    if (kind == Symbol.Constant || (kind != Symbol.Variable && kind != Symbol.Parameter))    {      throw new YAPLException(CompilerError.SymbolIllegalUse, assi, t);    }  }}void IFSTATEMENT() :{}{  < IF > EXPR() < THEN > STATEMENTLIST() [ < ELSE > STATEMENTLIST() ] < ENDIF >}void WHILESTATEMENT() :{}{  < WHILE > EXPR() < DO > STATEMENTLIST() < ENDWHILE >}void RETURNSTATEMENT() :{}{  < RETURN > [ EXPR() ]}void WRITESTATEMENT() :{}{  < WRITE > < STRING >}void STATEMENT() :{}{  IFSTATEMENT()| WHILESTATEMENT()| RETURNSTATEMENT()| WRITESTATEMENT()| LOOKAHEAD(2)  ASSIGNMENT()| PROCEDURECALL()| BLOCK()}void STATEMENTLIST() :{}{  (    STATEMENT() < SEMICOLON >  )*}void BLOCK() :{}{  {    symTable.openScope(false);  }  [ DECL() ] < BEGIN > STATEMENTLIST() < END >  {    symTable.closeScope();  }}Token PRIMTYPE() :{	Token t;}{ t = < INTEGER >| t = < BOOLEAN >{  return t;}}Type TYPE() :{  Token t;  int dim = 0;}{  t = PRIMTYPE() (< LBRACKET > < RBRACKET >  {    dim++;  }  )*  {    if (dim > 0) return new ArrayType(false, Type.getTypeOfImage(t.image), t, dim);    else return new Type(false, Type.getTypeOfImage(t.image), t);  }}void RETURNTYPE() :{}{  < VOID >| TYPE()}void CONSTDECL() :{  Token t;  Token t_sec;  Type type;}{  < CONST > t = < IDENT > < IS > t_sec = LITERAL() < SEMICOLON >  {    Symbol constdec = symTable.lookupCurrentScope(t.image);    if (constdec != null)    {      throw new YAPLException(CompilerError.SymbolExists, constdec, t);    }    else    {      if (t_sec.image.equals("True") || t_sec.image.equals("False")) type = new Type(true, Type.CONST, t_sec);      else type = new Type(true, Type.INT, t_sec);      constdec = new SymbolImpl(Symbol.Constant, t.image);      symTable.addSymbol(constdec);    }  }}void VARDECL() :{  Token t;  Type type;}{  type = TYPE() t = < IDENT >  {    Symbol vardecl = symTable.lookupCurrentScope(t.image);    if (vardecl != null)    {      throw new YAPLException(CompilerError.SymbolExists, vardecl, t);    }    else    {      vardecl = new SymbolImpl(Symbol.Variable, t.image);      symTable.addSymbol(vardecl);      vardecl.setType(type);    }  }  (    < COMMA > t = < IDENT >    {      vardecl = symTable.lookupCurrentScope(t.image);      if (vardecl != null)      {        throw new YAPLException(CompilerError.SymbolExists, vardecl, t);      }      else      {        vardecl = new SymbolImpl(Symbol.Variable, t.image);        vardecl.setType(type);        symTable.addSymbol(vardecl);      }    }  )*  < SEMICOLON >}void DECL() :{}{  < DECLARE >  (    CONSTDECL()  | VARDECL()  )*}void FORMALPARAM() :{  Token t;}{  [ < READONLY > ] TYPE() t = < IDENT >  {    Symbol form = symTable.lookupCurrentScope(t.image);    if (form != null)    {      throw new YAPLException(CompilerError.SymbolExists, form, t);    }    else    {      form = new SymbolImpl(Symbol.Parameter, t.image);      symTable.addSymbol(form);    }  }}void FORMALPARAMLIST() :{}{  FORMALPARAM()  (    < COMMA > FORMALPARAM()  )*}void PROCEDURE() :{  Token t;}{  < PROCEDURE > RETURNTYPE() t = < IDENT >  {    Symbol procedure = symTable.lookupCurrentScope(t.image);    if (procedure != null)    {      throw new YAPLException(CompilerError.SymbolExists, procedure, t);    }    else    {      procedure = new SymbolImpl(Symbol.Procedure, t.image);      symTable.addSymbol(procedure);      symTable.openScope(false);      symTable.setParentSymbol(procedure);    }  }  < LPAR > [ FORMALPARAMLIST() ] < RPAR > BLOCK() t = < IDENT >  {    Symbol procedureClose = symTable.getNearestParentSymbol(Symbol.Procedure);    if (!procedureClose.getName().equals(t.image)) throw new YAPLException(CompilerError.EndIdentMismatch, procedureClose, t);    else symTable.closeScope();  }  < SEMICOLON >}void PROGRAM() :{  Token t;}{  < PROGRAM > t = < IDENT >  {    program_name = t.image;    Symbol programStart = new SymbolImpl(Symbol.Program, t.image);    /** Open Universe Scope which contains predefined Procedures */    symTable.openScope(true);    symTable.setParentSymbol(null);    /** put predefined procedures in symbol table */    pre_writeln = new SymbolImpl(Symbol.Procedure, "writeln");    symTable.addSymbol(pre_writeln);    pre_writeint = new SymbolImpl(Symbol.Procedure, "writeint");    symTable.addSymbol(pre_writeint);    pre_writebool = new SymbolImpl(Symbol.Procedure, "writebool");    symTable.addSymbol(pre_writebool);    pre_readint = new SymbolImpl(Symbol.Procedure, "readint");    symTable.addSymbol(pre_readint);    /** Open Programm Scope */    symTable.openScope(false);    symTable.setParentSymbol(programStart);  }  (    DECL()  | PROCEDURE()  )*  < BEGIN > STATEMENTLIST() < END > t = < IDENT >  {    Symbol endProgram = symTable.getNearestParentSymbol(Symbol.Program);    if (!endProgram.getName().equals(t.image)) throw new YAPLException(CompilerError.EndIdentMismatch, endProgram, t);    /** Close Program Scope */    symTable.closeScope();    /** Close Universe Scope */    symTable.closeScope();  }  < DOT >}/* Predefined Functions *//* Root node for production */void Start() :{}{  PROGRAM()}
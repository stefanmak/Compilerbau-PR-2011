 /** * Compiler of STEFAN MAK * options where taken from the example file generated by JavaCC */options{  JDK_VERSION = "1.5";  static = true;}PARSER_BEGIN(StefanMak)import yapl.interfaces.*;import yapl.lib.*;import yapl.impl.*;import java.io.FileInputStream;import java.io.File;import java.io.IOException;import java.util.*;/** Scanner for Compiler Milestone 1 */public class StefanMak{  /** Program Name for failure and debugging*/  private static String program_name;  /** Symbol Table */  private static SymboltableImpl symTable;  /** Declare predefined procedures as symbols */  private static Symbol pre_writeln;  private static Symbol pre_writeint;  private static Symbol pre_writebool;  private static Symbol pre_readint;    /** Main entry point. */  public static void main(String args []) throws TokenMgrError, YAPLException, ParseException  {    /** Declare variables for program read*/    File file = null;    FileInputStream fis = null;    symTable = new SymboltableImpl();    /** Read YAPL File from file */    if (args.length != 0)    {      try      {        file = new File(args [0]);        fis = new FileInputStream(file);      }      catch (IOException ex)      {        System.err.println(ex);      }    }    else    {      System.out.println("YAPL Program as first parameter needed...");      System.out.println("System exit...");      System.exit(0);    }    /** Create new Symbol Table */    /** Give my Parser the InputStream to start the work */    StefanMak parser = new StefanMak(fis);    try    {      parser.Start();      /** Parsing was correct and complete */      CompilerMessage.printOK(StefanMak.program_name);    }    catch (TokenMgrError ex)    {      /** Lexical Error etc. occured */      CompilerMessage.printError(ex, StefanMak.program_name);    }    catch (ParseException ex)    {      /** Parse Error occured */      CompilerMessage.printError(ex, StefanMak.program_name);    }    catch (YAPLException ex)    {      /** SymbolTable Error occured */      CompilerMessage.printError(ex, StefanMak.program_name);    }  }}PARSER_END(StefanMak)/** Skip NewLines etc. by parsing... (taken from example)*/SKIP :{  " "| "\r"| "\t"| "\n"}SPECIAL_TOKEN : /* for comments - not necessary nested!*//* (~[ ])* *//* Didn`t work on Test07 at Milestone2 */{  < COMMENT :    "/*"    (      ~[ "*" ]    | "*" ~[ "/" ]    )*    "*/" >}TOKEN : /* Elementary Words/Characters to prevent warnings*/{  < LPAR : "(" >| < RPAR : ")" >| < LBRACKET : "[" >| < RBRACKET : "]" >| < COMMA : "," >| < SEMICOLON : ";" >| < DOT : "." >| < IS : "=" >| < COLON : ":" >| < IF : "If" >| < ENDIF : "EndIf" >| < THEN : "Then" >| < ELSE : "Else" >| < OR : "Or" >| < VOID : "void" >| < AND : "And" >| < TRUE : "True" >| < FALSE : "False" >| < WHILE : "While" >| < ENDWHILE : "EndWhile" >| < DO : "Do" >| < RETURN : "Return" >| < WRITE : "Write" >| < BEGIN : "Begin" >| < END : "End" >| < PROCEDURE : "Procedure" >| < PROGRAM : "Program" >| < INTEGER : "int" >| < BOOLEAN : "bool" >| < CONST : "Const" >| < DECLARE : "Declare" >| < READONLY : "readonly" >| < NEW : "new" >| < BLANK : "#" >}TOKEN : /* Operations */{  < RELOP :    "<"  | "<="  | ">="  | ">" >| < EQUALOP :    "=="  | "!=" >| < ADDOP :    "+"  | "-" >| < MULOP :    "*"  | "/"  | "%" >}TOKEN : /* Basic Elements*/{  < NUMBER : < DIGIT > (< DIGIT >)* >| < DIGIT : [ "0"-"9" ] >| < IDENT :    < LETTER >    (      < LETTER >    | < DIGIT >    )* >| < STRING :    "\""    (      " "    | < LETTER >    | < DIGIT >    | < OTHERCHAR >    )*    "\"" >| < LETTER : [ "a"-"z", "A"-"Z", "_" ] >| < OTHERCHAR : [ "+", "-", "*", "/", ".", ",", ";", ":", "!", "?", "=", "#", "%", "<", ">", "$", "(", ")", "[", "]", "{", "}", "@", "&", "^", "|", "\\" ] >}/* Expressions */Token LITERAL() :{  Token t;}{  t = < TRUE >| t = < FALSE >| t = < NUMBER >  {    return t;  }}void SELECTOR() :{}{  < LBRACKET > EXPR() < RBRACKET > [ SELECTOR() ]}void ARRAYLEN() :{  Token t;}{  < BLANK > t = < IDENT > [ SELECTOR() ]  {    Symbol ident = symTable.lookup(t.image);    if (ident != null && (ident.getKind() != Symbol.Variable && ident.getKind() != Symbol.Parameter))    {      // wrong type not an array      throw new YAPLException(CompilerError.SymbolIllegalUse, ident, t);    }    else if (ident == null)    {      // Array not declared      throw new YAPLException(CompilerError.IdentNotDecl, ident, t);    }  }}Type PRIMARYEXPR() :{  Token t = null;  Type type = null;  Boolean select = false;  int dim;  Symbol symbol;}{  t = LITERAL()  {	if(t.image.equals("True") || t.image.equals("False"))	{	  type = new Type(false,Type.BOOL,t);	}else	{	  type = new Type(false,Type.INT,t);	}	     }| < LPAR > type = EXPR() < RPAR >| LOOKAHEAD(2)  type = PROCEDURECALL()  {    if(type.getType() == -1)    {      throw new YAPLException(CompilerError.ProcNotFuncExpr,      			new SymbolImpl(Symbol.Procedure,type.getToken().toString()),      			type.getToken());    }  }| t = < IDENT > [ SELECTOR() ]  {    Symbol ident = symTable.lookup(t.image);    if (ident != null && (ident.getKind() == Symbol.Procedure || ident.getKind() == Symbol.Program))    {      // wrong type      throw new YAPLException(CompilerError.SymbolIllegalUse, ident, t);    }    else if (ident == null)    {      // variable not declared      throw new YAPLException(CompilerError.IdentNotDecl, ident, t);    }  }| ARRAYLEN(){  return new Type(false,type.getType(),t);}}Type UNARYEXPR() :{		Type returnType;	Token t = null;}{  [ t = < ADDOP > ] returnType = PRIMARYEXPR()  {    if(t != null && (returnType.getType() == Type.BOOL    	|| returnType instanceof ArrayType))    	{    	  throw new YAPLException(CompilerError.IllegalOp1Type,null, t);    	}  }}Type MULEXPR() :{	Type type;	Type returnType;	Token t;}{  returnType = UNARYEXPR()  (   t = < MULOP > type = UNARYEXPR()   {     if((returnType.getType() != Type.BOOL && returnType.getType() != type.getType()))     {       throw new YAPLException(CompilerError.IllegalOp2Type,null, t);     }else if( type instanceof ArrayType || returnType instanceof ArrayType)     {       throw new YAPLException(CompilerError.IllegalOp2Type,null, t);     }else     {       returnType.setToken(t);     }        }  )*  {    return returnType;  }}Type ADDEXPR() :{	Type type;	Type returnType;	Token t;}{  returnType = MULEXPR()  (   t = < ADDOP > type = MULEXPR()   {     if((returnType.getType() != Type.BOOL && returnType.getType() != type.getType()))     {       throw new YAPLException(CompilerError.IllegalOp2Type,null, t);     }else if( type instanceof ArrayType || returnType instanceof ArrayType)     {       throw new YAPLException(CompilerError.IllegalOp2Type,null, t);     }else     {       returnType.setToken(t);     }        }  )*  {    return returnType;  }}Type RELEXPR() :{	Type type;	Type returnType;	Token t;}{  returnType = ADDEXPR() [ t = < RELOP > type = ADDEXPR()	{	  if(returnType.getType() == Type.BOOL || type.getType() == Type.BOOL	  	|| type instanceof ArrayType || returnType instanceof ArrayType)	  	{	  	  throw new YAPLException(CompilerError.IllegalRelOpType,null, t);	  	}else	  	{	  	  returnType = new Type(false, Type.BOOL, type.getToken());	  	}	  		}  ]  {    return returnType;  }}Type EQUALEXPR() :{	Token t;	Type type;	Type returnType;}{  returnType = RELEXPR() [ t = < EQUALOP > type = RELEXPR()	{	  if(returnType.getType() != type.getType() || (type instanceof ArrayType && !(returnType instanceof ArrayType)))	  {	    throw new YAPLException(CompilerError.IllegalEqualOpType,null,t);	  }	  returnType = new Type(false,Type.BOOL,type.getToken());	}  ]  {    return returnType;  }}Type CONDANDEXPR() :{	Type type;	Type returnType;	Token t;}{  returnType = EQUALEXPR()  (    t = < AND > type = EQUALEXPR()    {		if(returnType.getType() != Type.BOOL			|| type.getType() != Type.BOOL			|| type instanceof ArrayType			|| returnType instanceof ArrayType)			{			  throw new YAPLException(CompilerError.IllegalOp2Type,null,t);			}		returnType = new Type(false,Type.BOOL,type.getToken());	     }  )*  {    return returnType;  }}// Multidimensional ArraysType CREATIONEXPR() :{	Token t;	Token current = null;	Type type;	LinkedList<Type> types = new LinkedList<Type>();}{  < NEW > t = PRIMTYPE() < LBRACKET > type = EXPR() < RBRACKET >  (    < LBRACKET > EXPR() < RBRACKET >  )*  {    return new ArrayType(false,Type.getTypeOfImage(t.image),current,0);  }}Type EXPR() :{  	Token t;  		Type type;	Type returnType;}{  returnType = CONDANDEXPR()  (    t = < OR > type = CONDANDEXPR()    {      if(type.getType() != Type.BOOL || returnType.getType() != Type.BOOL)      {        throw new YAPLException(CompilerError.IllegalOp2Type,null,t);      }else      {        returnType = new Type(false,Type.BOOL,type.getToken());      }    }  )*  {    return returnType;  }| returnType = CREATIONEXPR(){  return returnType; }}void ARGUMENTLIST() :{}{  EXPR()  (    < COMMA > EXPR()  )*}Type PROCEDURECALL() :{  Token t;}{  t = < IDENT > < LPAR > [ ARGUMENTLIST() ] < RPAR >  {    Symbol ident = symTable.lookup(t.image);    if (ident != null && (ident.getKind() != Symbol.Procedure))    {      // wrong type not an array      throw new YAPLException(CompilerError.SymbolIllegalUse, ident, t);    }    else if (ident == null)    {      // Array not declared      throw new YAPLException(CompilerError.IdentNotDecl, ident, t);    }  }}void ASSIGNMENT() :{  Token t;}{  t = < IDENT > [ SELECTOR() ] ":=" EXPR()  {    Symbol assi = symTable.lookup(t.image);    int kind;    if (assi != null) kind = assi.getKind();    else throw new YAPLException(CompilerError.IdentNotDecl, assi, t);    if (kind == Symbol.Constant || (kind != Symbol.Variable && kind != Symbol.Parameter))    {      throw new YAPLException(CompilerError.SymbolIllegalUse, assi, t);    }  }}void IFSTATEMENT() :{}{  < IF > EXPR() < THEN > STATEMENTLIST() [ < ELSE > STATEMENTLIST() ] < ENDIF >}void WHILESTATEMENT() :{}{  < WHILE > EXPR() < DO > STATEMENTLIST() < ENDWHILE >}void RETURNSTATEMENT() :{}{  < RETURN > [ EXPR() ]}void WRITESTATEMENT() :{}{  < WRITE > < STRING >}void STATEMENT() :{}{  IFSTATEMENT()| WHILESTATEMENT()| RETURNSTATEMENT()| WRITESTATEMENT()| LOOKAHEAD(2)  ASSIGNMENT()| PROCEDURECALL()| BLOCK()}void STATEMENTLIST() :{}{  (    STATEMENT() < SEMICOLON >  )*}void BLOCK() :{}{  {    symTable.openScope(false);  }  [ DECL() ] < BEGIN > STATEMENTLIST() < END >  {    symTable.closeScope();  }}Token PRIMTYPE() :{	Token t;}{ t = < INTEGER >| t = < BOOLEAN >{  return t;}}Type TYPE() :{  Token t;  int dim = 0;}{  t = PRIMTYPE() (< LBRACKET > < RBRACKET >  {    dim++;  }  )*  {    if (dim > 0) return new ArrayType(false, Type.getTypeOfImage(t.image), t, dim);    else return new Type(false, Type.getTypeOfImage(t.image), t);  }}Type RETURNTYPE() :{	Token t = null;	Type type = null;}{ t = < VOID >| type = TYPE(){  if(t == null)  	return null;  else  	return type;}}void CONSTDECL() :{  Token t;  Token t_sec;  Type type;}{  < CONST > t = < IDENT > < IS > t_sec = LITERAL() < SEMICOLON >  {    Symbol constdec = symTable.lookupCurrentScope(t.image);    if (constdec != null)    {      throw new YAPLException(CompilerError.SymbolExists, constdec, t);    }    else    {      if (t_sec.image.equals("True") || t_sec.image.equals("False")) type = new Type(true, Type.CONST, t_sec);      else type = new Type(true, Type.INT, t_sec);      constdec = new SymbolImpl(Symbol.Constant, t.image);      symTable.addSymbol(constdec);    }  }}void VARDECL() :{  Token t;  Type type;}{  type = TYPE() t = < IDENT >  {    Symbol vardecl = symTable.lookupCurrentScope(t.image);    if (vardecl != null)    {      throw new YAPLException(CompilerError.SymbolExists, vardecl, t);    }    else    {      vardecl = new SymbolImpl(Symbol.Variable, t.image);      symTable.addSymbol(vardecl);      vardecl.setType(type);    }  }  (    < COMMA > t = < IDENT >    {      vardecl = symTable.lookupCurrentScope(t.image);      if (vardecl != null)      {        throw new YAPLException(CompilerError.SymbolExists, vardecl, t);      }      else      {        vardecl = new SymbolImpl(Symbol.Variable, t.image);        vardecl.setType(type);        symTable.addSymbol(vardecl);      }    }  )*  < SEMICOLON >}void DECL() :{}{  < DECLARE >  (    CONSTDECL()  | VARDECL()  )*}void FORMALPARAM() :{  Token t;}{  [ < READONLY > ] TYPE() t = < IDENT >  {    Symbol form = symTable.lookupCurrentScope(t.image);    if (form != null)    {      throw new YAPLException(CompilerError.SymbolExists, form, t);    }    else    {      form = new SymbolImpl(Symbol.Parameter, t.image);      symTable.addSymbol(form);    }  }}void FORMALPARAMLIST() :{}{  FORMALPARAM()  (    < COMMA > FORMALPARAM()  )*}void PROCEDURE() :{  Token t;  Token t_sec;  Type type;  }{  < PROCEDURE > type = RETURNTYPE() t = < IDENT >  {    Symbol procedure = symTable.lookupCurrentScope(t.image);    if (procedure != null)    {      throw new YAPLException(CompilerError.SymbolExists, procedure, t);    }    else    {      procedure = new SymbolImpl(Symbol.Procedure, t.image);      procedure.setType(type);      symTable.addSymbol(procedure);      symTable.openScope(false);      symTable.setParentSymbol(procedure);          }  }  < LPAR > [ FORMALPARAMLIST() ] < RPAR > BLOCK() t = < IDENT >  {    Symbol procedureClose = symTable.getNearestParentSymbol(Symbol.Procedure);    if (!procedureClose.getName().equals(t.image)) throw new YAPLException(CompilerError.EndIdentMismatch, procedureClose, t);    else symTable.closeScope();  }  < SEMICOLON >}void PROGRAM() :{  Token t;}{  < PROGRAM > t = < IDENT >  {    program_name = t.image;    Symbol programStart = new SymbolImpl(Symbol.Program, t.image);    /** Open Universe Scope which contains predefined Procedures */    symTable.openScope(true);    symTable.setParentSymbol(null);    /** put predefined procedures in symbol table */    pre_writeln = new SymbolImpl(Symbol.Procedure, "writeln");    symTable.addSymbol(pre_writeln);    pre_writeint = new SymbolImpl(Symbol.Procedure, "writeint");    symTable.addSymbol(pre_writeint);    pre_writebool = new SymbolImpl(Symbol.Procedure, "writebool");    symTable.addSymbol(pre_writebool);    pre_readint = new SymbolImpl(Symbol.Procedure, "readint");    symTable.addSymbol(pre_readint);    /** Open Programm Scope */    symTable.openScope(false);    symTable.setParentSymbol(programStart);  }  (    DECL()  | PROCEDURE()  )*  < BEGIN > STATEMENTLIST() < END > t = < IDENT >  {    Symbol endProgram = symTable.getNearestParentSymbol(Symbol.Program);    if (!endProgram.getName().equals(t.image)) throw new YAPLException(CompilerError.EndIdentMismatch, endProgram, t);    /** Close Program Scope */    symTable.closeScope();    /** Close Universe Scope */    symTable.closeScope();  }  < DOT >}/* Predefined Functions *//* Root node for production */void Start() :{}{  PROGRAM()}
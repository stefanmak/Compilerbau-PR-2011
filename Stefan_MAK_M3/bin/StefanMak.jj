 /** * Compiler of STEFAN MAK * options where taken from the example file generated by JavaCC */options{  JDK_VERSION = "1.5";  static = true;}PARSER_BEGIN(StefanMak)import yapl.interfaces.*;import yapl.lib.*;import yapl.impl.*;import java.io.FileInputStream;import java.io.File;import java.io.IOException;import java.util.*;/** Scanner for Compiler Milestone 1 */public class StefanMak{  /** Program Name for failure and debugging*/  private static String program_name;  /** Symbol Table */  private static SymboltableImpl symTable;  /** Declare predefined procedures as symbols */  private static Symbol pre_writeln;  private static Symbol pre_writeint;  private static Symbol pre_writebool;  private static Symbol pre_readint;  /** stuff for procedures... */    /** is set if a procedure needs a return*/  private static boolean need_return;  /** is set if one path of a procedure gives a return*/  private static boolean set_return;  /** is set to a specific type for a procedure return */  private static Type returnType;  /** actual Procedure Symbol */  private static Symbol currentProcedureSymbol;    /** Main entry point. */  public static void main(String args []) throws TokenMgrError, YAPLException, ParseException  {    /** Declare variables for program read*/    File file = null;    FileInputStream fis = null;    symTable = new SymboltableImpl();    /** Read YAPL File from file */    if (args.length != 0)    {      try      {        file = new File(args [0]);        fis = new FileInputStream(file);      }      catch (IOException ex)      {        System.err.println(ex);      }    }    else    {      System.out.println("YAPL Program as first parameter needed...");      System.out.println("System exit...");      System.exit(0);    }    /** Create new Symbol Table */    /** Give my Parser the InputStream to start the work */    StefanMak parser = new StefanMak(fis);    try    {      parser.Start();      /** Parsing was correct and complete */      CompilerMessage.printOK(StefanMak.program_name);    }    catch (TokenMgrError ex)    {      /** Lexical Error etc. occured */      CompilerMessage.printError(ex, StefanMak.program_name);    }    catch (ParseException ex)    {      /** Parse Error occured */      CompilerMessage.printError(ex, StefanMak.program_name);    }    catch (YAPLException ex)    {      /** SymbolTable Error occured */      CompilerMessage.printError(ex, StefanMak.program_name);    }  }}PARSER_END(StefanMak)/** Skip NewLines etc. by parsing... (taken from example)*/SKIP :{  " "| "\r"| "\t"| "\n"}SPECIAL_TOKEN : /* for comments - not necessary nested!*//* (~[ ])* *//* Didn`t work on Test07 at Milestone2 */{  < COMMENT :    "/*"    (      ~[ "*" ]    | "*" ~[ "/" ]    )*    "*/" >}TOKEN : /* Elementary Words/Characters to prevent warnings*/{  < LPAR : "(" >| < RPAR : ")" >| < LBRACKET : "[" >| < RBRACKET : "]" >| < COMMA : "," >| < SEMICOLON : ";" >| < DOT : "." >| < IS : "=" >| < COLON : ":" >| < IF : "If" >| < ENDIF : "EndIf" >| < THEN : "Then" >| < ELSE : "Else" >| < OR : "Or" >| < VOID : "void" >| < AND : "And" >| < TRUE : "True" >| < FALSE : "False" >| < WHILE : "While" >| < ENDWHILE : "EndWhile" >| < DO : "Do" >| < RETURN : "Return" >| < WRITE : "Write" >| < BEGIN : "Begin" >| < END : "End" >| < PROCEDURE : "Procedure" >| < PROGRAM : "Program" >| < INTEGER : "int" >| < BOOLEAN : "bool" >| < CONST : "Const" >| < DECLARE : "Declare" >| < READONLY : "readonly" >| < NEW : "new" >| < BLANK : "#" >}TOKEN : /* Operations */{  < RELOP :    "<"  | "<="  | ">="  | ">" >| < EQUALOP :    "=="  | "!=" >| < ADDOP :    "+"  | "-" >| < MULOP :    "*"  | "/"  | "%" >}TOKEN : /* Basic Elements*/{  < NUMBER : < DIGIT > (< DIGIT >)* >| < DIGIT : [ "0"-"9" ] >| < IDENT :    < LETTER >    (      < LETTER >    | < DIGIT >    )* >| < STRING :    "\""    (      " "    | < LETTER >    | < DIGIT >    | < OTHERCHAR >    )*    "\"" >| < LETTER : [ "a"-"z", "A"-"Z", "_" ] >| < OTHERCHAR : [ "+", "-", "*", "/", ".", ",", ";", ":", "!", "?", "=", "#", "%", "<", ">", "$", "(", ")", "[", "]", "{", "}", "@", "&", "^", "|", "\\" ] >}/* Expressions */Token LITERAL() :{  Token t;}{  t = < TRUE >  {    return t;  }| t = < FALSE >  {    return t;  }| t = < NUMBER >  {    return t;  }}int SELECTOR() :{	Type type;	Token t;	int dim = 0;}{  < LBRACKET > type = EXPR() t = < RBRACKET > [ dim = SELECTOR() ]  {        if(type.getType() != Type.INT || (type instanceof ArrayType))     {      throw new YAPLException(CompilerError.BadArraySelector, null, t);          }    dim++;    return dim;   }}void ARRAYLEN() :{  Token t;  Token t_sec;  int dim = 0;}{  t_sec = < BLANK > t = < IDENT > [ dim = SELECTOR() ]  {        Symbol ident = symTable.lookup(t.image);        if (ident != null && (ident.getKind() != Symbol.Variable && ident.getKind() != Symbol.Parameter))    {      // wrong type not an array      throw new YAPLException(CompilerError.SymbolIllegalUse, ident, t);    }    else if (ident == null)    {      // Array not declared      throw new YAPLException(CompilerError.IdentNotDecl, ident, t);    }    else if((! (ident.getType() instanceof ArrayType)) || ((ArrayType)ident.getType()).getDimension() == dim)    {             throw new YAPLException(CompilerError.ArrayLenNotArray,ident, t_sec);    }  }}Type PRIMARYEXPR() :{  Token t = null;  Type type = null;  Boolean select = false;  int dim = 0;  Symbol symbol;  }{  t = LITERAL()  {	if(t.image.equals("True") || t.image.equals("False"))	{	  type = new Type(false,Type.BOOL,t);	}else	{	  type = new Type(false,Type.INT,t);	}	type.setToken(t);    return type; 	     }| < LPAR > type = EXPR() < RPAR >{    return type;}| LOOKAHEAD(2)  type = PROCEDURECALL()  {        if(type.getType() == Type.OTHER)    {      throw new YAPLException(CompilerError.ProcNotFuncExpr,      			new SymbolImpl(Symbol.Procedure,type.getToken().toString()),      			type.getToken());    }        return type;  }| t = < IDENT > [ dim = SELECTOR() ]  {        Symbol ident = symTable.lookup(t.image);	        if (ident != null && (ident.getKind() == Symbol.Procedure || ident.getKind() == Symbol.Program))    {      // wrong type      throw new YAPLException(CompilerError.SymbolIllegalUse, ident, t);    }    else if (ident == null)    {      // variable not declared      throw new YAPLException(CompilerError.IdentNotDecl, ident, t);    }    else if(dim >= 1 && ((!(ident.getType() instanceof ArrayType)) || (((ArrayType)ident.getType()).getDimension() - dim) < 0))    {              throw new YAPLException(CompilerError.SelectorNotArray,ident, t);    }else if(dim >= 1 && ((ArrayType) ident.getType()).getDimension() == dim)	{	     	   return new Type(ident.getType().isReadOnly(), ident.getType().getType(), t);   	         }    else    {		   	   if(ident.getType() instanceof ArrayType )   	   {   	      // Maybe SubArray        	      return new ArrayType(ident.getType().isReadOnly(), ident.getType().getType(), t,((ArrayType)ident.getType()).getDimension()-dim);   	    }   	   else   	   {   	         	      return new Type(ident.getType().isReadOnly(), ident.getType().getType(), t);   	    }          }  }| ARRAYLEN(){    return new Type(false,Type.INT,t);}}Type UNARYEXPR() :{		Type returnType;	Token t = null;}{  [ t = < ADDOP > ] returnType = PRIMARYEXPR()  {    if(t != null && (returnType.getType() == Type.BOOL    	|| returnType instanceof ArrayType))    	{    	  throw new YAPLException(CompilerError.IllegalOp1Type,null, t);    	}    	else    	{    	  if(t!=null)    	  {    	    returnType.setToken(t);    	  }    	       	  return returnType;    	}  }}Type MULEXPR() :{	Type type;	Type returnType;	Token t;}{  returnType = UNARYEXPR()    (   t = < MULOP > type = UNARYEXPR()   {     if((returnType.getType() != Type.BOOL && returnType.getType() != type.getType()))     {       throw new YAPLException(CompilerError.IllegalOp2Type,null, t);     }else if( type instanceof ArrayType || returnType instanceof ArrayType)     {       throw new YAPLException(CompilerError.IllegalOp2Type,null, t);     }else     {       returnType.setToken(t);     }        }  )*  {        return returnType;  }}Type ADDEXPR() :{	Type type;	Type returnType;	Token t;}{  returnType = MULEXPR()  (   t = < ADDOP > type = MULEXPR()   {     if((returnType.getType() != Type.BOOL && returnType.getType() != type.getType()))     {       throw new YAPLException(CompilerError.IllegalOp2Type,null, t);     }else if( type instanceof ArrayType || returnType instanceof ArrayType)     {       throw new YAPLException(CompilerError.IllegalOp2Type,null, t);     }else     {              returnType.setToken(t);     }        }  )*  {        return returnType;  }}Type RELEXPR() :{	Type type;	Type returnType;	Token t;}{  returnType = ADDEXPR() [ t = < RELOP > type = ADDEXPR()	{	  if(returnType.getType() == Type.BOOL || type.getType() == Type.BOOL	  	|| type instanceof ArrayType || returnType instanceof ArrayType)	  	{	  	  throw new YAPLException(CompilerError.IllegalRelOpType,null, t);	  	}else	  	{	  	  returnType = new Type(false, Type.BOOL, type.getToken());	  	}	  		}  ]  {        return returnType;  }}Type EQUALEXPR() :{	Token t;	Type type;	Type returnType;}{  returnType = RELEXPR() [ t = < EQUALOP > type = RELEXPR()	{	  if(returnType.getType() != type.getType() || (type instanceof ArrayType && !(returnType instanceof ArrayType)))	  {	    throw new YAPLException(CompilerError.IllegalEqualOpType,null,t);	  }	  returnType = new Type(false,Type.BOOL,type.getToken());	}  ]  {        return returnType;  }}Type CONDANDEXPR() :{	Type type;	Type returnType;	Token t;}{  returnType = EQUALEXPR()  (    t = < AND > type = EQUALEXPR()    {		if(returnType.getType() != Type.BOOL			|| type.getType() != Type.BOOL			|| type instanceof ArrayType			|| returnType instanceof ArrayType)			{			  throw new YAPLException(CompilerError.IllegalOp2Type,null,t);			}		returnType = new Type(false,Type.BOOL,type.getToken());	     }  )*  {        return returnType;  }}// Multidimensional ArraysType CREATIONEXPR() :{	Token t;	Token t_sec;	Type type;	LinkedList<Type> types = new LinkedList<Type>();	int dim = 1;}{  < NEW > t = PRIMTYPE() < LBRACKET > type = EXPR() t_sec = < RBRACKET >  {    if(type.getType() == Type.BOOL)    {      throw new YAPLException(CompilerError.BadArraySelector,null,t_sec);    }  }  (    < LBRACKET > type = EXPR() t_sec = < RBRACKET >    {            if(type.getType() == Type.BOOL)      {        throw new YAPLException(CompilerError.BadArraySelector,null,t_sec);      }      dim++;    }  )*  {        return new ArrayType(false,Type.getTypeOfImage(t.image),t,dim);  }}Type EXPR() :{  	Token t;  		Type type;	Type returnType;}{  returnType = CONDANDEXPR()  (    t = < OR > type = CONDANDEXPR()    {            if(type.getType() != Type.BOOL || returnType.getType() != Type.BOOL)      {        throw new YAPLException(CompilerError.IllegalOp2Type,null,t);      }else      {                returnType = new Type(false,Type.BOOL,type.getToken());      }    }  )*  {        return returnType;  }| returnType = CREATIONEXPR(){    return returnType; }}int ARGUMENTLIST(Symbol procedureName) :{	int arguments = 1;	int counter = 1;	Symbol start = procedureName.getNextSymbol();	LinkedList<Type > argumentList = new LinkedList<Type >();	Type type;	}{    type = EXPR()  {    argumentList.add(type);  }    (        < COMMA > type = EXPR()    {      argumentList.add(type);      arguments++;    }     )*  {    while(start != null)    {            if(start.getType().getType() != argumentList.getFirst().getType())      {        argumentList.getFirst().getToken().setImage("" + counter);                throw new YAPLException(CompilerError.ArgNotApplicable,procedureName,argumentList.getFirst().getToken());      }      counter++;      start = start.getNextSymbol();      argumentList.removeFirst();    }    if(argumentList.size() > 0)    {      argumentList.getFirst().getToken().setImage("" + counter);      throw new YAPLException(CompilerError.ArgNotApplicable,procedureName,argumentList.getFirst().getToken());    }    return arguments;  }}Type PROCEDURECALL() :{  Token t;  Token t_sec;  Type type;  int arguments = 0;}{  t = < IDENT >   {        Symbol ident = symTable.lookup(t.image);    if (ident != null && (ident.getKind() != Symbol.Procedure))    {      // wrong type not an array      throw new YAPLException(CompilerError.SymbolIllegalUse, ident, t);    }    else if (ident == null)    {      // Array not declared      throw new YAPLException(CompilerError.IdentNotDecl, ident, t);    }  }  < LPAR > [ arguments = ARGUMENTLIST(ident) ] t_sec = < RPAR >  {      	// Count arguments      	Symbol start = ident.getNextSymbol();      	int counter = 0;		while(start != null)		{		  start = start.getNextSymbol();		  counter++;		  		}		if(counter > arguments)		{		  throw new YAPLException(CompilerError.TooFewArgs,ident,t_sec);		}		      	    	if(ident.getType() == null)    	{    	      		type = new Type(false, Type.OTHER, t);    	}    	else if(ident.getType() instanceof ArrayType)    	{    	         		type = new ArrayType(false,ident.getType().getType(), t, ((ArrayType)ident.getType()).getDimension());        }    	else    	{    	         		type = new Type(false, ident.getType().getType(), t);        }       		return type;     }  }void ASSIGNMENT() :{  Token t;  Token t_sec;  Type type;  boolean selectorUsed = false;  }{  t = < IDENT > [ SELECTOR(){selectorUsed = true;}] t_sec = ":=" type = EXPR()  {        Symbol assi = symTable.lookup(t.image);    int kind;    if(assi != null)    {       kind = assi.getKind();    }    else    {       throw new YAPLException(CompilerError.IdentNotDecl, assi, t);    }    if (kind == Symbol.Constant || (kind != Symbol.Variable && kind != Symbol.Parameter))    {      throw new YAPLException(CompilerError.SymbolIllegalUse, assi, t);    }    // Type Checks				    if(assi.getType().isReadOnly())    {      throw new YAPLException(CompilerError.ReadonlyAssign, assi, t);    }else if(      		 !(      		   (		          !(assi.getType() instanceof ArrayType)		          && !(type instanceof ArrayType)		          && assi.getType().getType()==type.getType()		        )      		    ||      		     (      		      (assi.getType() instanceof ArrayType)      		   	  && (type instanceof ArrayType)      		   	  && (((ArrayType)assi.getType()).getDimension() == ((ArrayType)type).getDimension())      		   	)		        		        ||		         (		           selectorUsed		           && (assi.getType() instanceof ArrayType)		           && !(type instanceof ArrayType)		           && (assi.getType().getType() == type.getType())		         )		             		 			         )		   )		{		  	      		throw new YAPLException(CompilerError.TypeMismatchAssign, assi, t_sec);          	}           }}void IFSTATEMENT() :{  		Type type;	}{  < IF > type = EXPR() < THEN >  {		if(type.getType() != Type.BOOL)		{		  		  throw new YAPLException(CompilerError.CondNotBool,null,type.getToken());		}	     }   STATEMENTLIST() [ < ELSE > STATEMENTLIST() ] < ENDIF >}void WHILESTATEMENT() :{		Type type;}{  < WHILE > type = EXPR() < DO >{  		if(type.getType() != Type.BOOL)		{		  		  throw new YAPLException(CompilerError.CondNotBool,null,type.getToken());		}}  STATEMENTLIST() < ENDWHILE >}void RETURNSTATEMENT() :{  Type type = null;  Token t;}{  t = < RETURN >  {    set_return = true;  }  [ type = EXPR()]  {    if(currentProcedureSymbol == null && type != null)    {      if(type == null)      {              	throw new YAPLException(CompilerError.IllegalRetValMain,currentProcedureSymbol,t);      }else      {        throw new YAPLException(CompilerError.IllegalRetValMain,currentProcedureSymbol,type.getToken());      }      	          }    else if(type != null && returnType == null)    {            throw new YAPLException(CompilerError.IllegalRetValProc,currentProcedureSymbol,type.getToken());    }    else if(type == null && returnType != null)    {           throw new YAPLException(CompilerError.InvalidReturnType,currentProcedureSymbol,t);    }    else if(type != null && returnType != null && type.getType() != returnType.getType())    {           throw new YAPLException(CompilerError.InvalidReturnType,currentProcedureSymbol,type.getToken());    }            }}void WRITESTATEMENT() :{}{  < WRITE > < STRING >}void STATEMENT() :{}{  IFSTATEMENT()| WHILESTATEMENT()| RETURNSTATEMENT()| WRITESTATEMENT()| LOOKAHEAD(2)  ASSIGNMENT()| PROCEDURECALL()| BLOCK()}void STATEMENTLIST() :{}{  (    STATEMENT() < SEMICOLON >  )*}Token BLOCK() :{	Token t;}{  {    symTable.openScope(false);  }  [ DECL() ] < BEGIN > STATEMENTLIST() t = < END >  {    symTable.closeScope();    return t;  }}Token PRIMTYPE() :{	Token t;	}{ t = < INTEGER > {      return t; } | t = < BOOLEAN >{      return t;}}Type TYPE() :{  Token t;  int dim = 0;}{  t = PRIMTYPE() (< LBRACKET > < RBRACKET >  {        dim++;  }  )*  {    if (dim > 0) return new ArrayType(false, Type.getTypeOfImage(t.image), t, dim);    else return new Type(false, Type.getTypeOfImage(t.image), t);  }}Type RETURNTYPE() :{	Token t = null;	Type type = null;}{ t = < VOID > {      return new Type(false,Type.OTHER,t); }| type = TYPE(){  	return type;}}void CONSTDECL() :{  Token t;  Token t_sec;  Type type;}{  < CONST > t = < IDENT > < IS > t_sec = LITERAL() < SEMICOLON >  {    Symbol constdec = symTable.lookupCurrentScope(t.image);    if (constdec != null)    {      throw new YAPLException(CompilerError.SymbolExists, constdec, t);    }    else    {      if (t_sec.image.equals("True") || t_sec.image.equals("False")) type = new Type(true, Type.CONST, t_sec);      else type = new Type(true, Type.INT, t_sec);      constdec = new SymbolImpl(Symbol.Constant, t.image);      constdec.setType(type);      symTable.addSymbol(constdec);    }  }}void VARDECL() :{  Token t;  Type type;}{  type = TYPE() t = < IDENT >  {    Symbol vardecl = symTable.lookupCurrentScope(t.image);    if (vardecl != null)    {      throw new YAPLException(CompilerError.SymbolExists, vardecl, t);    }    else    {      vardecl = new SymbolImpl(Symbol.Variable, t.image);      symTable.addSymbol(vardecl);            vardecl.setType(type);    }  }  (    < COMMA > t = < IDENT >    {      vardecl = symTable.lookupCurrentScope(t.image);      if (vardecl != null)      {        throw new YAPLException(CompilerError.SymbolExists, vardecl, t);      }      else      {        vardecl = new SymbolImpl(Symbol.Variable, t.image);                vardecl.setType(type);                symTable.addSymbol(vardecl);      }    }  )*  < SEMICOLON >}void DECL() :{}{  < DECLARE >  (    CONSTDECL()  | VARDECL()  )*}Symbol FORMALPARAM() :{  Token t;  Type type;  boolean readOnly = false;  }{  [ < READONLY > { readOnly = true; }] type = TYPE() t = < IDENT >  {    Symbol form = symTable.lookupCurrentScope(t.image);    if (form != null)    {      throw new YAPLException(CompilerError.SymbolExists, form, t);    }    else    {            form = new SymbolImpl(Symbol.Parameter, t.image);      form.setType(type);      symTable.addSymbol(form);      return form;    }  }}Symbol FORMALPARAMLIST() :{  Symbol returnSymbol;  Symbol s1,s2;}{  s1 = FORMALPARAM()  {    returnSymbol = s1;  }  (      < COMMA > s2 = FORMALPARAM()    { s1.setNextSymbol(s2);      s1 = s2;    }  )*  {    return returnSymbol;  }}void PROCEDURE() :{  Token t;  Token t_sec;  Type type;  Symbol startSymbol = null;}{  < PROCEDURE > type = RETURNTYPE() t = < IDENT >  {        Symbol procedure = symTable.lookupCurrentScope(t.image);    if (procedure != null)    {      throw new YAPLException(CompilerError.SymbolExists, procedure, t);    }    else    {      procedure = new SymbolImpl(Symbol.Procedure, t.image);      procedure.setType(type);      currentProcedureSymbol = procedure;      	  if(type.getType() == Type.OTHER)	  {	    	    need_return = false;	    returnType = null;	    	    	  }else	  {	    need_return = true;	    returnType = type;	    	  }	  set_return = false;	  	             symTable.addSymbol(procedure);      symTable.openScope(false);      symTable.setParentSymbol(procedure);                }      }  < LPAR > [startSymbol = FORMALPARAMLIST()]  {    if(startSymbol != null)    {      procedure.setNextSymbol(startSymbol);    }  }  < RPAR > t_sec = BLOCK() t = < IDENT >  {    //System.out.println(returnType.getType() + " - " +  procedure.getType().getType());    Symbol procedureClose = symTable.getNearestParentSymbol(Symbol.Procedure);    if (!procedureClose.getName().equals(t.image))    {      throw new YAPLException(CompilerError.EndIdentMismatch, procedureClose, t);    }    else if(need_return && (      						!(( (procedure.getType() instanceof ArrayType)    							&& (type instanceof ArrayType)    							&& (((ArrayType)procedure.getType()).getDimension() == ((ArrayType)type).getDimension()))    						||		      			 	(!(procedure.getType() instanceof ArrayType)		      			 		&& !(type instanceof ArrayType)		      			 		&& procedure.getType().getType()== type.getType()))		         		 	)		         		 	)    {      throw new YAPLException(CompilerError.InvalidReturnType,procedure,t_sec);    }else if(need_return && !set_return)    {      throw new YAPLException(CompilerError.MissingReturn,procedure,t_sec);    }        else    {       symTable.closeScope();       currentProcedureSymbol = null;    }  }  < SEMICOLON >}void PROGRAM() :{  Token t;}{  < PROGRAM > t = < IDENT >  {    program_name = t.image;    Symbol programStart = new SymbolImpl(Symbol.Program, t.image);    /** Open Universe Scope which contains predefined Procedures */    symTable.openScope(true);    symTable.setParentSymbol(null);        /** put predefined procedures in symbol table */    pre_writeln = new SymbolImpl(Symbol.Procedure, "writeln");    symTable.addSymbol(pre_writeln);        pre_writeint = new SymbolImpl(Symbol.Procedure, "writeint");	SymbolImpl predefinedArgument = new SymbolImpl(Symbol.Parameter,"");	predefinedArgument.setType(new Type(false, Type.INT,null));	pre_writeint.setNextSymbol(predefinedArgument);        pre_writeint.setType(new Type(false, Type.INT,null));    symTable.addSymbol(pre_writeint);    pre_writebool = new SymbolImpl(Symbol.Procedure, "writebool");    symTable.addSymbol(pre_writebool);    pre_readint = new SymbolImpl(Symbol.Procedure, "readint");    pre_readint.setType(new Type(false, Type.INT,null));    symTable.addSymbol(pre_readint);        /** Open Programm Scope */    symTable.openScope(false);    symTable.setParentSymbol(programStart);  }  (    DECL()  | PROCEDURE()  )*  < BEGIN > STATEMENTLIST() < END > t = < IDENT >  {    Symbol endProgram = symTable.getNearestParentSymbol(Symbol.Program);    if (!endProgram.getName().equals(t.image)) throw new YAPLException(CompilerError.EndIdentMismatch, endProgram, t);    /** Close Program Scope */    symTable.closeScope();    /** Close Universe Scope */    symTable.closeScope();  }  < DOT >}/* Predefined Functions *//* Root node for production */void Start() :{}{  PROGRAM()}
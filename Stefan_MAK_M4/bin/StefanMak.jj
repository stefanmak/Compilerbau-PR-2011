 /** * Compiler of STEFAN MAK * options where taken from the example file generated by JavaCC */options{  JDK_VERSION = "1.5";    static = true;}PARSER_BEGIN(StefanMak)import yapl.interfaces.*;import yapl.lib.*;import yapl.impl.*;import java.io.FileInputStream;import java.io.File;import java.io.IOException;import java.util.*;import java.io.*;import java.util.HashMap;/** Compiler (Scanner, Parser, TypeChecker and CodeGenerator) */public class StefanMak{  /** Program Name - for failure and debugging*/  private static String program_name;  /** Symbol Table - for storing used Symbols (Variables, ProcNames, ...) */  private static SymboltableImpl symTable;  /** Declaration of the four predefined YAPL procedures as symbols */  private static Symbol pre_writeln;  private static Symbol pre_writeint;  private static Symbol pre_writebool;  private static Symbol pre_readint;  /** Argument List - stores the types of arguments of the actual procedure (in order) **/  private static LinkedList<Type > argumentList;  /** Declaration for the CodeGenerator **/  private static CodeGenerator cg = null;    /** HashMap which contains all variables - for CodeGeneration **/    private static HashMap<String,Attrib > variablesMap = new HashMap<String,Attrib >();  /** Variable for  */    /** is set if a procedure needs a return*/  private static boolean need_return;  /** is set if one path of a procedure gives a return*/  private static boolean set_return;  /** is set to a specific type for a procedure return */  private static Type returnType;  /** actual Procedure Symbol */  private static Symbol currentProcedureSymbol;    /** Main entry point */  public static void main(String args []) throws TokenMgrError, YAPLException, ParseException  {		        /** Declare variables for reading the source program */    File file = null;    FileInputStream fis = null;    /** Declare variables for writing the destination program */	File outputFile = null;	FileOutputStream fout = null;	PrintStream prout = null;	        /** Create new Symbol Table */    symTable = new SymboltableImpl();        /** Read YAPL Program from file */    if (args.length == 2)    {      try      {        /** Read the input file */               file = new File(args [0]);        fis = new FileInputStream(file);			/** Open the output file */        outputFile = new File(args [1]);                /** If it not exists - > create it */        if(!outputFile.exists())        	outputFile.createNewFile();        fout = new FileOutputStream(outputFile);        prout = new PrintStream(fout);		/** Initialize the CodeGenerator with the output stream */        cg = new CodeGenerator(prout);      }      catch (IOException ex)      {        System.err.println(ex);      }    }    else    {      System.out.println("YAPL Program as first parameter needed and destination file as second");      System.out.println("System exit...");      System.exit(0);    }            /** Give my Scanner/Parser/Generator the InputStream to start the work */    StefanMak parser = new StefanMak(fis);        try    {      /** Starts the analysing process */      parser.Start();            /** If method above terminates - > everything was correct */      CompilerMessage.printOK(StefanMak.program_name);      /** Close the Printstream */      prout.close();          }    catch (TokenMgrError ex)    {      /** Lexical Error etc. occured */      CompilerMessage.printError(ex, StefanMak.program_name);    }    catch (ParseException ex)    {      /** Parse Error occured */      CompilerMessage.printError(ex, StefanMak.program_name);    }    catch (YAPLException ex)    {      /** SymbolTable Error occured */      CompilerMessage.printError(ex, StefanMak.program_name);    }  }}PARSER_END(StefanMak)/** Skip NewLines, tabs, etc. by analysing/parsing */SKIP :{  " "| "\r"| "\t"| "\n"}/** Definition of special tokens - > for Comments* 	(~[ ])*    < - Didn`t work on Test07 at Milestone2 * 	~[ "*" ] means every character except '*'*/SPECIAL_TOKEN : {  < COMMENT :    "/*"    (      ~[ "*" ] | "*" ~[ "/" ]    )*    "*/" >}/** Elementary Words/Characters for readability and to prevent warnings */TOKEN : {  < LPAR : "(" >| < RPAR : ")" >| < LBRACKET : "[" >| < RBRACKET : "]" >| < COMMA : "," >| < SEMICOLON : ";" >| < DOT : "." >| < IS : "=" >| < COLON : ":" >| < IF : "If" >| < ENDIF : "EndIf" >| < THEN : "Then" >| < ELSE : "Else" >| < OR : "Or" >| < VOID : "void" >| < AND : "And" >| < TRUE : "True" >| < FALSE : "False" >| < WHILE : "While" >| < ENDWHILE : "EndWhile" >| < DO : "Do" >| < RETURN : "Return" >| < WRITE : "Write" >| < BEGIN : "Begin" >| < END : "End" >| < PROCEDURE : "Procedure" >| < PROGRAM : "Program" >| < INTEGER : "int" >| < BOOLEAN : "bool" >| < CONST : "Const" >| < DECLARE : "Declare" >| < READONLY : "readonly" >| < NEW : "new" >| < BLANK : "#" >}/** Relational- and Basic Operations */TOKEN : {  < RELOP :    "<"  | "<="  | ">="  | ">" >| < EQUALOP :    "=="  | "!=" >| < ADDOP :    "+"  | "-" >| < MULOP :    "*"  | "/"  | "%" >}/** Basic Elements */TOKEN : {  < NUMBER : < DIGIT > (< DIGIT >)* >| < DIGIT : [ "0"-"9" ] >| < IDENT :    < LETTER >    (      < LETTER >    | < DIGIT >    )* >| < STRING :    "\""    (      " "    | < LETTER >    | < DIGIT >    | < OTHERCHAR >    )*    "\"" >| < LETTER : [ "a"-"z", "A"-"Z", "_" ] >| < OTHERCHAR : [ "+", "-", "*", "/", ".", ",", ";", ":", "!", "?", "=", "#", "%", "<", ">", "$", "(", ")", "[", "]", "{", "}", "@", "&", "^", "|", "\\" ] >}/** Expressions */Token LITERAL() :{  Token t;}{  t = < TRUE >  {    return t;  }| t = < FALSE >  {    return t;  }| t = < NUMBER >  {    return t;  }}/** Selctor for an Array Element  arr[3][x][x-7] */int SELECTOR() :{	Type type;	Token t;	int dim = 0;}{  < LBRACKET > type = EXPR() t = < RBRACKET > [ dim = SELECTOR() ]  {    // if type of the Expression in the selection is not Integer - > Throw error    if(type.getType() != Type.INT || (type instanceof ArrayType))     {      throw new YAPLException(CompilerError.BadArraySelector, null, t);          }    // Maybe more than one dimension, so increment dim to return the overall dimension    dim++;    return dim;   }}/** Length of an Array #arr or #arr[] (on multidimensional) */void ARRAYLEN() :{  Token t;  Token t_sec;  int dim = 0;}{  t_sec = < BLANK > t = < IDENT > [ dim = SELECTOR() ]  {    // Array has to be declared before you can get its length    Symbol ident = symTable.lookup(t.image);    // If Array declared but is not a variable or parameter - > Error    if (ident != null && (ident.getKind() != Symbol.Variable && ident.getKind() != Symbol.Parameter))    {            throw new YAPLException(CompilerError.SymbolIllegalUse, ident, t);    }    // If Array not declared before - > Error    else if (ident == null)    {            throw new YAPLException(CompilerError.IdentNotDecl, ident, t);    }    // If identifier is not an Array or identifier is array but element access (dimArr == accessDim) - > Error    else if((! (ident.getType() instanceof ArrayType)) || ((ArrayType)ident.getType()).getDimension() == dim)    {             throw new YAPLException(CompilerError.ArrayLenNotArray,ident, t_sec);    }  }}/** Primary Expressions ( True, False, x+2, x[], write('bla') */Type PRIMARYEXPR() :{  Token t = null;  Type type = null;  Boolean select = false;  int dim = 0;  Symbol symbol;  }{  // True, False, Number  t = LITERAL()  {	if(t.image.equals("True") || t.image.equals("False"))	{	  // Type(readonly,type,token)	  type = new Type(false,Type.BOOL,t);	}else	{	  // Type(readonly,type,token)	  type = new Type(false,Type.INT,t);	}	// Set the token of the actual type	type.setToken(t);    return type; 	     }  // (3*x) (x==y) ...| < LPAR > type = EXPR() < RPAR >{    return type;}  // writeint(5), calcPivot(x)| LOOKAHEAD(2)  type = PROCEDURECALL()  {    // procedure doesn't have a return value - > not a function    if(type.getType() == Type.OTHER)    {      throw new YAPLException(CompilerError.ProcNotFuncExpr,      			new SymbolImpl(Symbol.Procedure,type.getToken().toString()),      			type.getToken());    }        return type;  }  // x , x[3], ...| t = < IDENT > [ dim = SELECTOR() ]  {    // Element has already been declared    Symbol ident = symTable.lookup(t.image);	    // Element isn't a Variable, Const or Parameter - > Error    if (ident != null && (ident.getKind() == Symbol.Procedure || ident.getKind() == Symbol.Program))    {      // wrong type      throw new YAPLException(CompilerError.SymbolIllegalUse, ident, t);    }    // Element is currently not declared - > Error    else if (ident == null)    {      // variable not declared      throw new YAPLException(CompilerError.IdentNotDecl, ident, t);    }    // Element used as an Array but is not an ArrayType or Element is ArrayType but selected Dimension is too deep     else if(dim >= 1 && ((!(ident.getType() instanceof ArrayType)) || (((ArrayType)ident.getType()).getDimension() - dim) < 0))    {              throw new YAPLException(CompilerError.SelectorNotArray,ident, t);    }	// Element is an Array and access dimension is same as Array Dimension - > Type = 'normal' Type    else if(dim >= 1 && ((ArrayType) ident.getType()).getDimension() == dim)	{	     	   return new Type(ident.getType().isReadOnly(), ident.getType().getType(), t);   	         }        else    {       // Element is an Array and return is a SubArray 		   	   if(ident.getType() instanceof ArrayType )   	   {   	         	      return new ArrayType(ident.getType().isReadOnly(), ident.getType().getType(), t,((ArrayType)ident.getType()).getDimension()-dim);   	   }   	   // Element is a 'normal' Type    	   else   	   {   	     // Type(readonly,type,token) 	         	      return new Type(ident.getType().isReadOnly(), ident.getType().getType(), t);   	   }          }  }  // #x| ARRAYLEN(){  // Type(readonly,type,token)  return new Type(false,Type.INT,t);}}/** UnaryExpr = [AddOp] PrimaryExpr - >  +/-  True, x , y[2], #x, calc(x) */Type UNARYEXPR() :{		Type returnType;	Token t = null;}{  // Primary Expression with optional Addoperation in front  [ t = < ADDOP > ] returnType = PRIMARYEXPR()  {    // if +/- in front and returnType is Bool or Arraytype - > Error    if(t != null && (returnType.getType() == Type.BOOL || returnType instanceof ArrayType))    {    	throw new YAPLException(CompilerError.IllegalOp1Type,null, t);    }    else    {        // if +/- is not null - > set it to type    	if(t!=null){    		returnType.setToken(t);    	}    	       	return returnType;    }  }}/** MulExpr = UnaryExpr { MulOp UnaryExpr } - > y[2] * x * 2 , x * 3 */Type MULEXPR() :{  	// More than one type variable is needed to check 'recursive' the type compatibility	Type type;	Type returnType;	Token t;}{  // Set the first return type   returnType = UNARYEXPR()    (   t = < MULOP > type = UNARYEXPR()   {     // next expression must not be a Bool and equivalent to the first type - > Error      if((returnType.getType() != Type.BOOL && returnType.getType() != type.getType()))     {       throw new YAPLException(CompilerError.IllegalOp2Type,null, t);     }	 // if one of the two (or both) types are Arrays - > Error     else if( type instanceof ArrayType || returnType instanceof ArrayType)     {       throw new YAPLException(CompilerError.IllegalOp2Type,null, t);     }	 // both are of same type and mulOp can be applied     else     {       returnType.setToken(t);     }        }  )*  {        return returnType;  }}/** AddExpr = MulExpr { AddOp MulExpr } (Defines also the 'binding') - > x*y + a[2] */Type ADDEXPR() :{    // More than one type variable is needed to check 'recursive' the type compatibility	Type type;	Type returnType;	Token t;}{  // Set the first return type  returnType = MULEXPR()  (   t = < ADDOP > type = MULEXPR()   {     // next expression must not be a Bool and equivalent to the first type - > Error     if((returnType.getType() != Type.BOOL && returnType.getType() != type.getType()))     {       throw new YAPLException(CompilerError.IllegalOp2Type,null, t);     }	 // if one of the two (or both) types are Arrays - > Error     else if( type instanceof ArrayType || returnType instanceof ArrayType)     {       throw new YAPLException(CompilerError.IllegalOp2Type,null, t);     } 	// both are of same type and AddOp can be applied     else     {              returnType.setToken(t);     }        }  )*  {        return returnType;  }}/** RelExpr = AddExpr [ RelOp AddExpr ] - > x*2+y/2 > z */Type RELEXPR() :{    // Two type variables needed for evaluation of the Relational Operation	Type type;	Type returnType;	Token t;}{  returnType = ADDEXPR() [ t = < RELOP > type = ADDEXPR()	{	  // Relational Operation only on numbers - > Bool and Arrays - > Error	  if(returnType.getType() == Type.BOOL || type.getType() == Type.BOOL	  	|| type instanceof ArrayType || returnType instanceof ArrayType)	  {	  	  throw new YAPLException(CompilerError.IllegalRelOpType,null, t);	  }	  // Relational Operator was on numbers - > Result is a bool	  else	  {	      // Type(readonly,type,token)	  	  returnType = new Type(false, Type.BOOL, type.getToken());	  }	  		}  ]  {        return returnType;  }}/** RelExpr [ EqualOp RelExpr ] - > 3 < x == 7 > 4*x */Type EQUALEXPR() :{    // Two Types needed for evaluation of the Expression	Token t;	Type type;	Type returnType;}{  // Set the types  returnType = RELEXPR() [ t = < EQUALOP > type = RELEXPR()	{	  // both types are not equal or one of both types is an array - > Array	  if(returnType.getType() != type.getType() || (type instanceof ArrayType && !(returnType instanceof ArrayType)))	  {	    throw new YAPLException(CompilerError.IllegalEqualOpType,null,t);	  }	  // Types are INT or BOOL - > Expression can be evaulated - > Result is BOOL	  returnType = new Type(false,Type.BOOL,type.getToken());	}  ]  {        return returnType;  }}/** EqualExpr { 'And' EqualExpr } - > y == z And x = FALSE */Type CONDANDEXPR() :{    // Two Types needed for evaluation of the Expression 'recursive'	Type type;	Type returnType;	Token t;}{  // set return type of first Equalexpression  returnType = EQUALEXPR()  (    // set return type of next Equalexpression    t = < AND > type = EQUALEXPR()    {        // if one of the types isn't BOOL or an array of BOOLs - > Error		if(returnType.getType() != Type.BOOL			|| type.getType() != Type.BOOL			|| type instanceof ArrayType			|| returnType instanceof ArrayType)			{			  throw new YAPLException(CompilerError.IllegalOp2Type,null,t);			}		// Type(readonly,type,token)		returnType = new Type(false,Type.BOOL,type.getToken());	     }  )*  {        return returnType;  }}/**  "new" PrimType "[" Expr "]" { "[" Expr "]" } - > Creation of Arrays or Multidimensional Arrays */Type CREATIONEXPR() :{    // Two Tokens for exact Errors	Token t;	Token t_sec;	Type type;	//LinkedList<Type> types = new LinkedList<Type>();	int dim = 1;}{  < NEW > t = PRIMTYPE() < LBRACKET > type = EXPR() t_sec = < RBRACKET >  {    // if Array Selector is a RelOperation etc. an type == BOOL - > Error    if(type.getType() == Type.BOOL)    {      // Type(readonly,type,token)      throw new YAPLException(CompilerError.BadArraySelector,null,t_sec);    }  }  (    // if Array Selector is a RelOperation etc. an type == BOOL - > Error    < LBRACKET > type = EXPR() t_sec = < RBRACKET >    {            if(type.getType() == Type.BOOL)      {        // Type(readonly,type,token)        throw new YAPLException(CompilerError.BadArraySelector,null,t_sec);      }      // increment Dimension for every time an [] occurs      dim++;    }  )*  {    // Type(readonly,type,token,dimension of the Array)    return new ArrayType(false,Type.getTypeOfImage(t.image),t,dim);  }}/** CondAndExpr { 'Or' CondAndExpr } | CreationExpr - > Every kind of 'normal' expression (incl. logical And & Or)*/Type EXPR() :{    // Two Types needed for 'recursive' evaluation of types on CondAndExpr  	Token t;  		Type type;	Type returnType;}{  // Set return Type of first expression  returnType = CONDANDEXPR()  (    // Set return Type of next expression    t = < OR > type = CONDANDEXPR()    {      // For logical 'OR' every type must be BOOL instead - > ERROR      if(type.getType() != Type.BOOL || returnType.getType() != Type.BOOL)      {        throw new YAPLException(CompilerError.IllegalOp2Type,null,t);      }	  // Both Expressions evaluate to TRUE or FALSE - > BOOL as returnType [Log. AND / OR, <, >]      else      {                returnType = new Type(false,Type.BOOL,type.getToken());      }    }  )*  {        return returnType;  }| returnType = CREATIONEXPR(){    return returnType; }}/** Argumentlist of a Procedure - > Foo(x,2,True)...*	Takes a Symbol as Parameter to get all Parameters of the Procedure and their order.*	Returns number of arguments.*/int ARGUMENTLIST(Symbol procedureName) :{  	// Variable Declaration - > if Argumentlist is processed - > minimum one argument must have been occured	int arguments = 1;	int counter = 1;	// Get first argument via procedureName	Symbol start = procedureName.getNextSymbol();	// Saves all Types of the arguments in order	argumentList = new LinkedList<Type >();	// Saves temporary all Types of the arguments in order	LinkedList<Type > tempList = new LinkedList<Type >();	Type type;	}{  // add first argument to the lists  type = EXPR()  {    argumentList.add(type);        tempList.add(type);  }    (    // more than one argument passed - > add them and increment argument counter    < COMMA > type = EXPR()    {      argumentList.add(type);      tempList.add(type);      arguments++;    }     )*  {    // Little checking ;-) - > do it for all entries in the argument List       while(start != null && !argumentList.isEmpty())    {      // If the predefined procedure 'writebool' is called - > don't throw Errors - >      // cause predefined type for argument is BOOL - > but could also be a CONST      if(procedureName.getName().equals("writebool") && argumentList.getFirst().getType() == 2)      {              }      // If actual Type of the Argument List is not the same type as it is defined      // (--,--,start (bool),--)  < - > (--,--,(int),--)    <-- for third argument	  else if(start.getType().getType() != argumentList.getFirst().getType())      {                              argumentList.getFirst().getToken().setImage("" + counter);                throw new YAPLException(CompilerError.ArgNotApplicable,procedureName,argumentList.getFirst().getToken());      }	  // If actual element is of Type Array but doesn't have the same dimension      else if(start.getType() instanceof ArrayType      		&& argumentList.getFirst() instanceof ArrayType			&& (((ArrayType)argumentList.getFirst()).getDimension()				!=((ArrayType)start.getType()).getDimension())      		)      {        argumentList.getFirst().getToken().setImage("" + counter);                throw new YAPLException(CompilerError.ArgNotApplicable,procedureName,argumentList.getFirst().getToken());      }	  // If actual element	is of Type Array but is set to ReadOnly but Procedure is Read/Write      else if((start.getType() instanceof ArrayType)				&& ((ArrayType)argumentList.getFirst()).isReadOnly()				&& !start.getType().isReadOnly()      			)            {        argumentList.getFirst().getToken().setImage("" + counter);                throw new YAPLException(CompilerError.ReadonlyArg,procedureName,argumentList.getFirst().getToken());      }      // Increment counter of arguments and set next symbol of procedure as start symbol and remove first element      // of argumentList (passed).      counter++;      start = start.getNextSymbol();      argumentList.removeFirst();    }	// If we have arguments left - > ERROR too much arguments          if(argumentList.size() > 0)    {            argumentList.getFirst().getToken().setImage("" + counter);      throw new YAPLException(CompilerError.ArgNotApplicable,procedureName,argumentList.getFirst().getToken());    }	// Restore the whole argument list and return it    argumentList = tempList;    return arguments;  }}/** ident "(" [ ArgumentList ] ")" - > calc(x,y,True) ... */Type PROCEDURECALL() :{  Token t;  Token t_sec;  Type type;  int arguments = 0;}{  t = < IDENT >   {    // Procedure has to be defined before usage    Symbol ident = symTable.lookup(t.image);    // Element is declared but isn't a procedure    if (ident != null && (ident.getKind() != Symbol.Procedure))    {            throw new YAPLException(CompilerError.SymbolIllegalUse, ident, t);    }    // Element isn't declared    else if (ident == null)    {            throw new YAPLException(CompilerError.IdentNotDecl, ident, t);    }	  }  < LPAR > [ arguments = ARGUMENTLIST(ident) ] t_sec = < RPAR >  {      	// Count arguments of the defined procedure      	Symbol start = ident.getNextSymbol();      	int counter = 0;		while(start != null)		{		  start = start.getNextSymbol();		  counter++;		  		}		// Defined Procedure has more arguments than argumentlist - > ERROR		if(counter > arguments)		{		  throw new YAPLException(CompilerError.TooFewArgs,ident,t_sec);		}		      	// If ident is not declared - > Type is Error Type [OTHER] <- Redundant because Exception thrown above    	if(ident.getType() == null)    	{    	      		type = new Type(false, Type.OTHER, t);    	}    	// Return Type is an Array Type    	else if(ident.getType() instanceof ArrayType)    	{    	         		type = new ArrayType(false,ident.getType().getType(), t, ((ArrayType)ident.getType()).getDimension());        }        // Return Type is INT or BOOL    	else    	{    	         		type = new Type(false, ident.getType().getType(), t);        }		/** CodeGen for procedurecall **/        cg.callProcedure(symTable.lookup(t.image),argumentList,variablesMap);        		return type;     }  }/** ident [ Selector ] ":=" Expr  - > x := 3,... */void ASSIGNMENT() :{  Token t;  Token t_sec;  Type type;  boolean selectorUsed = false;  }{  t = < IDENT > [ SELECTOR(){selectorUsed = true;}] t_sec = ":=" type = EXPR()  {        // Assigned symbol has already been declared    Symbol assi = symTable.lookup(t.image);    int kind;    if(assi != null)    {       kind = assi.getKind();    }    // Symbol/Variable has not been declared - > Error    else    {       throw new YAPLException(CompilerError.IdentNotDecl, assi, t);    }	// If Variable is a constant or procedure or program - > Error    if (kind == Symbol.Constant || (kind != Symbol.Variable && kind != Symbol.Parameter))    {      throw new YAPLException(CompilerError.SymbolIllegalUse, assi, t);    }    // If Parameter in Procedure is set to readonly, it can't be assigned - > Error			    if(assi.getType().isReadOnly())    {      throw new YAPLException(CompilerError.ReadonlyAssign, assi, t);    }	// Example x := y	// First Block	//		x is not an Array	//		y is not an Array	//		x and y have the same type	// Second Block	//		x is an Array	//		y is an Array	//		x and y have the same dimension	// Third Block	//		x is an Array - > used with selection x[3]	//		y is not an Array	//		x and y have the same basic type	// If none of this blocks True - > ERROR    else if(      		 !(      		   (		          !(assi.getType() instanceof ArrayType)		          && !(type instanceof ArrayType)		          && assi.getType().getType()==type.getType()		        )      		    ||      		     (      		      (assi.getType() instanceof ArrayType)      		   	  && (type instanceof ArrayType)      		   	  && (((ArrayType)assi.getType()).getDimension() == ((ArrayType)type).getDimension())      		   	)		        		        ||		         (		           selectorUsed		           && (assi.getType() instanceof ArrayType)		           && !(type instanceof ArrayType)		           && (assi.getType().getType() == type.getType())		         )		             		 			         )		   )		{		  	      		throw new YAPLException(CompilerError.TypeMismatchAssign, assi, t_sec);          	} 	   	/** Code Generation **/   	// Get first attrib from Data Structure   	AttribImpl attrib = (AttribImpl) variablesMap.get(t.image);   	// Make new attrib for Code Generation   	AttribImpl expr = new AttribImpl();   	// Set type for Code Generation   	expr.setType(type);	   	   	// Generate Code for Assignment   	cg.assign(attrib,expr);   	   }}/** 'If' Expr 'Then' StatementList [ 'Else' StatementList ] 'EndIf' */void IFSTATEMENT() :{  		Type type;	}{  < IF > type = EXPR() < THEN >  {    	// Expression has to be BOOL for evaluation		if(type.getType() != Type.BOOL)		{		  		  throw new YAPLException(CompilerError.CondNotBool,null,type.getToken());		}	     }   STATEMENTLIST() [ < ELSE > STATEMENTLIST() ] < ENDIF >}/** 'While' Expr 'Do' StatementList 'EndWhile' */void WHILESTATEMENT() :{		Type type;}{  < WHILE > type = EXPR() < DO >{  		// Expression has to be BOOL for evaluation  		if(type.getType() != Type.BOOL)		{		  		  throw new YAPLException(CompilerError.CondNotBool,null,type.getToken());		}}  STATEMENTLIST() < ENDWHILE >}/** 'Return' [ Expr ] - > Has to be the same as the procedure defines*/void RETURNSTATEMENT() :{  Type type = null;  Token t;}{  t = < RETURN >  {    // minimum one path of the procedure returns (something)     set_return = true;  }  [ type = EXPR()]  {	// Checks if the programm is currently in an Procedure or the Expr() is used (not null)    if(currentProcedureSymbol == null && type != null)    {      // return without value      if(type == null)      {              	throw new YAPLException(CompilerError.IllegalRetValMain,currentProcedureSymbol,t);      }	  // return without procedure scope      else      {        throw new YAPLException(CompilerError.IllegalRetValMain,currentProcedureSymbol,type.getToken());      }      	          }    // Current Procedure exists and type is not null but current procedure doesn't need a return statement (void)    else if(type != null && returnType == null)    {            throw new YAPLException(CompilerError.IllegalRetValProc,currentProcedureSymbol,type.getToken());    }    // Current Procedure exists but type is null but return Type is needed    else if(type == null && returnType != null)    {           throw new YAPLException(CompilerError.InvalidReturnType,currentProcedureSymbol,t);    }    // Current Procedure exists, type exists and return Type is needed - > but different types    else if(type != null && returnType != null && type.getType() != returnType.getType())    {           throw new YAPLException(CompilerError.InvalidReturnType,currentProcedureSymbol,type.getToken());    }            }}/** 'Write' string */void WRITESTATEMENT() :{Token t;}{  < WRITE > t = < STRING >  {    /** Generate immediate Write Code */    cg.writeString(t.image);  }}/** 	IfStatement | WhileStatement | ReturnStatement*		| WriteStatement | Assignment | ProcedureCall | Block*/void STATEMENT() :{}{  IFSTATEMENT()| WHILESTATEMENT()| RETURNSTATEMENT()| WRITESTATEMENT()| LOOKAHEAD(2)  ASSIGNMENT()| PROCEDURECALL()| BLOCK()}/** { Statement ";" } */void STATEMENTLIST() :{}{  (    // List of Statements seperated by ;    STATEMENT() < SEMICOLON >  )*}/** [ Decl ] 'Begin' StatementList 'End'  - > For Procedure Scope or Main Scope */Token BLOCK() :{	Token t;}{  {    // Open a new Scope    symTable.openScope(false);  }  [ DECL() ] < BEGIN > STATEMENTLIST() t = < END >  {    // Close current Scope     symTable.closeScope();    return t;  }}/** 'int' | 'bool' - > For var/array declaration or return types*/Token PRIMTYPE() :{	Token t;	}{ t = < INTEGER > {      return t; } | t = < BOOLEAN >{      return t;}}/** PrimType { "[" "]" } - > For var/array declaration, return types or parameters */Type TYPE() :{  Token t;  int dim = 0;}{  t = PRIMTYPE() (< LBRACKET > < RBRACKET >  {    // increment dimension (for multidimensional arrays)    dim++;  }  )*  {    // create ArrayType if dim is greater than 0    if (dim > 0)    {      return new ArrayType(false, Type.getTypeOfImage(t.image), t, dim);    }    // otherwise create new Type - > out of string with helperfunction      else    {      return new Type(false, Type.getTypeOfImage(t.image), t);    }  }}/** 'void' | Type - > void or Primitive Type or ArrayType*/Type RETURNTYPE() :{	Token t = null;	Type type = null;}{ t = < VOID > {   // returns new Type with Sort - > OTHER   return new Type(false,Type.OTHER,t); }| type = TYPE(){  	// returns new Type (Primitive or ArrayType)  	return type;}}/** 'Const' ident '=' Literal ';' */void CONSTDECL() :{  Token t;  Token t_sec;  Type type;}{  < CONST > t = < IDENT > < IS > t_sec = LITERAL() < SEMICOLON >  {    // Lookup if there is a symbol with the same identifier in this scope    Symbol constdec = symTable.lookupCurrentScope(t.image);    // If Symbol exists in this scope - > Error    if (constdec != null)    {      throw new YAPLException(CompilerError.SymbolExists, constdec, t);    }    // Create new Symbol    else    {      // if declaration is a BOOL      if (t_sec.image.equals("True") || t_sec.image.equals("False"))      {              	type = new Type(true, Type.BOOL, t_sec);      }      // declaration is an INT      else      {        type = new Type(true, Type.INT, t_sec);      }      // create new symbol with given type      constdec = new SymbolImpl(Symbol.Constant, t.image);      constdec.setType(type);      // is a global variable       constdec.setGlobal(true);      // add it to symbol table      symTable.addSymbol(constdec);	      /** Code Generation **/      // create a new attribute with given type      AttribImpl attrib = new AttribImpl();      attrib.setType(type);      // allocate variable       cg.allocVariable(constdec);      // get the offset of the constdeclr      attrib.setOffset(constdec.getOffset());      // add it to the global map of variables            variablesMap.put(t.image,attrib);          }  }}/** Type ident { ',' ident } ';' - > int x,y,z; */void VARDECL() :{  Token t;  Type type;}{  type = TYPE() t = < IDENT >  {    // Lookup if first variable has been declared in this scope    Symbol vardecl = symTable.lookupCurrentScope(t.image);    // Variable already exists in current scope    if (vardecl != null)    {      throw new YAPLException(CompilerError.SymbolExists, vardecl, t);    }    // Variable is free - > create it    else    {      // create new Symbol      vardecl = new SymbolImpl(Symbol.Variable, t.image);      // add it to symbolTable      symTable.addSymbol(vardecl);      // set the actual type            vardecl.setType(type);      /** Code Generation **/      // create new attribute            AttribImpl attrib = new AttribImpl();      // set the actual type      attrib.setType(type);      // allocate Space for the variable      cg.allocVariable(vardecl);      // set the offset to attrib      attrib.setOffset(vardecl.getOffset());      // add it to the global map of variables                variablesMap.put(t.image,attrib);          }  }  (    < COMMA > t = < IDENT >    {      // Lookup if next variable has been declared in this scope      vardecl = symTable.lookupCurrentScope(t.image);      // If Symbol exists in this scope - > Error      if (vardecl != null)      {        throw new YAPLException(CompilerError.SymbolExists, vardecl, t);      }      // Variable is free - > create it      else      {        // create new Symbol        vardecl = new SymbolImpl(Symbol.Variable, t.image);                       vardecl.setType(type);        // add it to symbolTable        symTable.addSymbol(vardecl);        /** Code Generation **/        // create new attribute      	    AttribImpl attrib = new AttribImpl();	    // set the actual type	    attrib.setType(type);	    // allocate Space for the variable   	    cg.allocVariable(vardecl);	    // set the offset to attrib	    attrib.setOffset(vardecl.getOffset());	    // add it to the global map of variables    	    variablesMap.put(t.image,attrib);	          }    }  )*  < SEMICOLON >}/** 'Declare' { ConstDecl | VarDecl } */void DECL() :{}{  < DECLARE >  (    CONSTDECL()  | VARDECL()  )*}/** [ 'readonly' ] Type ident - > One Parameter of a Function/Procedure */Symbol FORMALPARAM() :{  Token t;  Type type;  boolean readOnly = false;  }{  [ < READONLY > { readOnly = true; }] type = TYPE() t = < IDENT >  {    // Lookup if variable has already been declared in this scope - > procedure calc(int x, int x <- ERROR)    Symbol form = symTable.lookupCurrentScope(t.image);    // Variable/Parameter exists already - > ERROR    if (form != null)    {      throw new YAPLException(CompilerError.SymbolExists, form, t);    }	// Readonly can only applied on ArrayTypes    else if(!(type instanceof ArrayType) && readOnly)    {      throw new YAPLException(CompilerError.ReadonlyNotArray, form, t);    }    // Create new Symbol    else    {            type.setReadOnly(readOnly);      // create new Symbol      form = new SymbolImpl(Symbol.Parameter, t.image);      // set the Type      form.setType(type);      // add symbol to symbol table      symTable.addSymbol(form);      return form;    }  }}/** FormalParam { ',' FormalParam } - > procedur calc(int x, bool y,...) */Symbol FORMALPARAMLIST() :{  Symbol returnSymbol;  Symbol s1,s2;}{  s1 = FORMALPARAM()  {    returnSymbol = s1;  }  (      < COMMA > s2 = FORMALPARAM()    {	  // Link the symbols of the formal parameter to a list! First points on Second, Second on Third...      s1.setNextSymbol(s2);      s1 = s2;    }  )*  {    return returnSymbol;  }}/** 'Procedure' ReturnType ident '(' [ FormalParamList ] ')' Block ident ';' */void PROCEDURE() :{  Token t;  Token t_sec;  Type type;  Symbol startSymbol = null;}{  < PROCEDURE > type = RETURNTYPE() t = < IDENT >  {    // Lookup if identifier has already been used in this scope     Symbol procedure = symTable.lookupCurrentScope(t.image);    if (procedure != null)    {      throw new YAPLException(CompilerError.SymbolExists, procedure, t);    }    // identifier is ready to use    else    {      // create new (Procedure) Symbol       procedure = new SymbolImpl(Symbol.Procedure, t.image);      // set actual (return) type of the symbol      procedure.setType(type);      // set the global Variable for later access in 'ReturnStatement'      currentProcedureSymbol = procedure;      // if (return) Type is VOID no return is needed 	  if(type.getType() == Type.OTHER)	  {	    	    need_return = false;	    returnType = null;	    	    	  }	  // set the global variables for later 'ReturnStatemen'	  else	  {	    need_return = true;	    returnType = type;	    	  }	  // set the global variable that no path return (actual) a return value	  set_return = false;	  	  // add symbol to symbol table	             symTable.addSymbol(procedure);      // open a new scope (the procedure scope)      symTable.openScope(false);      // set parent symbol of the actual scope to procedure      symTable.setParentSymbol(procedure);                }      }  < LPAR > [startSymbol = FORMALPARAMLIST()]  {    // procedure has parameters    if(startSymbol != null)    {      // set the next symbol of procedurescope for argumentlist      procedure.setNextSymbol(startSymbol);    }  }  < RPAR > t_sec = BLOCK() t = < IDENT >  {	// gets the nearest parent of kind 'Procedure' - > from top to bottom on Scope stack        Symbol procedureClose = symTable.getNearestParentSymbol(Symbol.Procedure);    // if procedure name is not the same as the identifier at the end - > Error    if (!procedureClose.getName().equals(t.image))    {      throw new YAPLException(CompilerError.EndIdentMismatch, procedureClose, t);    }    // if return is needed but not set - > Error	else if(need_return && !set_return)    {      throw new YAPLException(CompilerError.MissingReturn,procedure,t_sec);    }    // Procedure was correct        else    {       // close the procedure scope       symTable.closeScope();       // current procedure is null       currentProcedureSymbol = null;    }  }  < SEMICOLON >}/** 'Program' ident { Decl | Procedure } 'Begin' StatementList 'End' ident '.' - > First entry in the program */void PROGRAM() :{  Token t;}{  < PROGRAM > t = < IDENT >  {    // Set the global variable for program name    program_name = t.image;    // create new Symbol with the current program name    Symbol programStart = new SymbolImpl(Symbol.Program, t.image);    // Open Universe Scope which contains predefined Procedures    symTable.openScope(true);    symTable.setParentSymbol(null);        /** put predefined procedures in symbol table */    // writeln() - > has no parameter     pre_writeln = new SymbolImpl(Symbol.Procedure, "writeln");    symTable.addSymbol(pre_writeln);    // writeint(int x) - > with one parameter    pre_writeint = new SymbolImpl(Symbol.Procedure, "writeint");	// create predefined argument of type int	SymbolImpl predefinedArgument = new SymbolImpl(Symbol.Parameter,"");	// token is null		predefinedArgument.setType(new Type(false, Type.INT,null));	// link the argument to the procedure name	pre_writeint.setNextSymbol(predefinedArgument);            // add predefined procedure in symbol table    symTable.addSymbol(pre_writeint);    // writebool(bool b) - > with one parameter    pre_writebool = new SymbolImpl(Symbol.Procedure, "writebool");    // create predefined argument of type int    predefinedArgument = new SymbolImpl(Symbol.Parameter,"");    	predefinedArgument.setType(new Type(false, Type.BOOL,null));	// link the argument to the procedure name	pre_writebool.setNextSymbol(predefinedArgument);	// add predefined procedure in symbol table        symTable.addSymbol(pre_writebool);    // readint() - > no parameter    pre_readint = new SymbolImpl(Symbol.Procedure, "readint");    // set return type - > INT    pre_readint.setType(new Type(false, Type.INT,null));    // add to symbol table    symTable.addSymbol(pre_readint);        /** Open Programm Scope */    symTable.openScope(false);    symTable.setParentSymbol(programStart);    /** Generate Code for Programm Start **/    cg.back.enterMain();  }  (    DECL()  | PROCEDURE()  )*  < BEGIN > STATEMENTLIST() < END > t = < IDENT >  {    // check if the first symbol with the same parent symbol has the same name, if not - > Error    Symbol endProgram = symTable.getNearestParentSymbol(Symbol.Program);    if (!endProgram.getName().equals(t.image))    {          	throw new YAPLException(CompilerError.EndIdentMismatch, endProgram, t);    }    /** Close Program Scope */    symTable.closeScope();    /** Close Universe Scope */    symTable.closeScope();    /** Generate Code for Programm End **/    cg.back.exitMain("main_end");  }  < DOT >}/* Predefined Functions *//* Root node for productions */void Start() :{}{  PROGRAM()}
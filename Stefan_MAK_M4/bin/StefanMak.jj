 /** * Compiler of STEFAN MAK * options where taken from the example file generated by JavaCC */options{  JDK_VERSION = "1.5";    static = true;}PARSER_BEGIN(StefanMak)import yapl.interfaces.*;import yapl.lib.*;import yapl.impl.*;import java.io.FileInputStream;import java.io.File;import java.io.IOException;import java.util.*;import java.io.*;import java.util.HashMap;/** Compiler (Scanner, Parser, TypeChecker and CodeGenerator) */public class StefanMak{  /** Program Name - for failure and debugging*/  private static String program_name;  /** Symbol Table - for storing used Symbols (Variables, ProcNames, ...) */  private static SymboltableImpl symTable;  /** Declaration of the four predefined YAPL procedures as symbols */  private static Symbol pre_writeln;  private static Symbol pre_writeint;  private static Symbol pre_writebool;  private static Symbol pre_readint;  /** Argument List - stores the types of arguments of the actual procedure (in order) **/  private static LinkedList<Type > argumentList;  /** Declaration for the CodeGenerator **/  private static CodeGenerator cg = null;    /** HashMap which contains all variables - for CodeGeneration **/    private static HashMap<String,Attrib > variablesMap = new HashMap<String,Attrib >();  /** Variable for  */    /** is set if a procedure needs a return*/  private static boolean need_return;  /** is set if one path of a procedure gives a return*/  private static boolean set_return;  /** is set to a specific type for a procedure return */  private static Type returnType;  /** actual Procedure Symbol */  private static Symbol currentProcedureSymbol;    /** Main entry point */  public static void main(String args []) throws TokenMgrError, YAPLException, ParseException  {		        /** Declare variables for reading the source program */    File file = null;    FileInputStream fis = null;    /** Declare variables for writing the destination program */	File outputFile = null;	FileOutputStream fout = null;	PrintStream prout = null;	        /** Create new Symbol Table */    symTable = new SymboltableImpl();        /** Read YAPL Program from file */    if (args.length == 2)    {      try      {        /** Read the input file */               file = new File(args [0]);        fis = new FileInputStream(file);			/** Open the output file */        outputFile = new File(args [1]);                /** If it not exists - > create it */        if(!outputFile.exists())        	outputFile.createNewFile();        fout = new FileOutputStream(outputFile);        prout = new PrintStream(fout);		/** Initialize the CodeGenerator with the output stream */        cg = new CodeGenerator(prout);      }      catch (IOException ex)      {        System.err.println(ex);      }    }    else    {      System.out.println("YAPL Program as first parameter needed and destination file as second");      System.out.println("System exit...");      System.exit(0);    }            /** Give my Scanner/Parser/Generator the InputStream to start the work */    StefanMak parser = new StefanMak(fis);        try    {      /** Starts the analysing process */      parser.Start();            /** If method above terminates - > everything was correct */      CompilerMessage.printOK(StefanMak.program_name);      /** Close the Printstream */      prout.close();          }    catch (TokenMgrError ex)    {      /** Lexical Error etc. occured */      CompilerMessage.printError(ex, StefanMak.program_name);    }    catch (ParseException ex)    {      /** Parse Error occured */      CompilerMessage.printError(ex, StefanMak.program_name);    }    catch (YAPLException ex)    {      /** SymbolTable Error occured */      CompilerMessage.printError(ex, StefanMak.program_name);    }  }}PARSER_END(StefanMak)/** Skip NewLines, tabs, etc. by analysing/parsing */SKIP :{  " "| "\r"| "\t"| "\n"}/** Definition of special tokens - > for Comments* 	(~[ ])*    < - Didn`t work on Test07 at Milestone2 * 	~[ "*" ] means every character except '*'*/SPECIAL_TOKEN : {  < COMMENT :    "/*"    (      ~[ "*" ] | "*" ~[ "/" ]    )*    "*/" >}/** Elementary Words/Characters for readability and to prevent warnings */TOKEN : {  < LPAR : "(" >| < RPAR : ")" >| < LBRACKET : "[" >| < RBRACKET : "]" >| < COMMA : "," >| < SEMICOLON : ";" >| < DOT : "." >| < IS : "=" >| < COLON : ":" >| < IF : "If" >| < ENDIF : "EndIf" >| < THEN : "Then" >| < ELSE : "Else" >| < OR : "Or" >| < VOID : "void" >| < AND : "And" >| < TRUE : "True" >| < FALSE : "False" >| < WHILE : "While" >| < ENDWHILE : "EndWhile" >| < DO : "Do" >| < RETURN : "Return" >| < WRITE : "Write" >| < BEGIN : "Begin" >| < END : "End" >| < PROCEDURE : "Procedure" >| < PROGRAM : "Program" >| < INTEGER : "int" >| < BOOLEAN : "bool" >| < CONST : "Const" >| < DECLARE : "Declare" >| < READONLY : "readonly" >| < NEW : "new" >| < BLANK : "#" >}/** Relational- and Basic Operations */TOKEN : {  < RELOP :    "<"  | "<="  | ">="  | ">" >| < EQUALOP :    "=="  | "!=" >| < ADDOP :    "+"  | "-" >| < MULOP :    "*"  | "/"  | "%" >}/** Basic Elements */TOKEN : {  < NUMBER : < DIGIT > (< DIGIT >)* >| < DIGIT : [ "0"-"9" ] >| < IDENT :    < LETTER >    (      < LETTER >    | < DIGIT >    )* >| < STRING :    "\""    (      " "    | < LETTER >    | < DIGIT >    | < OTHERCHAR >    )*    "\"" >| < LETTER : [ "a"-"z", "A"-"Z", "_" ] >| < OTHERCHAR : [ "+", "-", "*", "/", ".", ",", ";", ":", "!", "?", "=", "#", "%", "<", ">", "$", "(", ")", "[", "]", "{", "}", "@", "&", "^", "|", "\\" ] >}/** Expressions */Token LITERAL() :{  Token t;}{  t = < TRUE >  {    return t;  }| t = < FALSE >  {    return t;  }| t = < NUMBER >  {    return t;  }}/** Selctor for an Array Element  arr[3][x][x-7] */int SELECTOR() :{	Type type;	Token t;	int dim = 0;}{  < LBRACKET > type = EXPR() t = < RBRACKET > [ dim = SELECTOR() ]  {    // if type of the Expression in the selection is not Integer - > Throw error    if(type.getType() != Type.INT || (type instanceof ArrayType))     {      throw new YAPLException(CompilerError.BadArraySelector, null, t);          }    // Maybe more than one dimension, so increment dim to return the overall dimension    dim++;    return dim;   }}/** Length of an Array #arr or #arr[] (on multidimensional) */void ARRAYLEN() :{  Token t;  Token t_sec;  int dim = 0;}{  t_sec = < BLANK > t = < IDENT > [ dim = SELECTOR() ]  {    // Array has to be declared before you can get its length    Symbol ident = symTable.lookup(t.image);    // If Array declared but is not a variable or parameter - > Error    if (ident != null && (ident.getKind() != Symbol.Variable && ident.getKind() != Symbol.Parameter))    {            throw new YAPLException(CompilerError.SymbolIllegalUse, ident, t);    }    // If Array not declared before - > Error    else if (ident == null)    {            throw new YAPLException(CompilerError.IdentNotDecl, ident, t);    }    // If identifier is not an Array or identifier is array but element access (dimArr == accessDim) - > Error    else if((! (ident.getType() instanceof ArrayType)) || ((ArrayType)ident.getType()).getDimension() == dim)    {             throw new YAPLException(CompilerError.ArrayLenNotArray,ident, t_sec);    }  }}/** Primary Expressions ( True, False, x+2, x[], write('bla') */Type PRIMARYEXPR() :{  Token t = null;  Type type = null;  Boolean select = false;  int dim = 0;  Symbol symbol;  }{  // True, False, Number  t = LITERAL()  {	if(t.image.equals("True") || t.image.equals("False"))	{	  // Type(readonly,type,token)	  type = new Type(false,Type.BOOL,t);	}else	{	  // Type(readonly,type,token)	  type = new Type(false,Type.INT,t);	}	// Set the token of the actual type	type.setToken(t);    return type; 	     }  // (3*x) (x==y) ...| < LPAR > type = EXPR() < RPAR >{    return type;}  // writeint(5), calcPivot(x)| LOOKAHEAD(2)  type = PROCEDURECALL()  {    // procedure doesn't have a return value - > not a function    if(type.getType() == Type.OTHER)    {      throw new YAPLException(CompilerError.ProcNotFuncExpr,      			new SymbolImpl(Symbol.Procedure,type.getToken().toString()),      			type.getToken());    }        return type;  }  // x , x[3], ...| t = < IDENT > [ dim = SELECTOR() ]  {    // Element has already been declared    Symbol ident = symTable.lookup(t.image);	    // Element isn't a Variable, Const or Parameter - > Error    if (ident != null && (ident.getKind() == Symbol.Procedure || ident.getKind() == Symbol.Program))    {      // wrong type      throw new YAPLException(CompilerError.SymbolIllegalUse, ident, t);    }    // Element is currently not declared - > Error    else if (ident == null)    {      // variable not declared      throw new YAPLException(CompilerError.IdentNotDecl, ident, t);    }    // Element used as an Array but is not an ArrayType or Element is ArrayType but selected Dimension is too deep     else if(dim >= 1 && ((!(ident.getType() instanceof ArrayType)) || (((ArrayType)ident.getType()).getDimension() - dim) < 0))    {              throw new YAPLException(CompilerError.SelectorNotArray,ident, t);    }	// Element is an Array and access dimension is same as Array Dimension - > Type = 'normal' Type    else if(dim >= 1 && ((ArrayType) ident.getType()).getDimension() == dim)	{	     	   return new Type(ident.getType().isReadOnly(), ident.getType().getType(), t);   	         }        else    {       // Element is an Array and return is a SubArray 		   	   if(ident.getType() instanceof ArrayType )   	   {   	         	      return new ArrayType(ident.getType().isReadOnly(), ident.getType().getType(), t,((ArrayType)ident.getType()).getDimension()-dim);   	   }   	   // Element is a 'normal' Type    	   else   	   {   	     // Type(readonly,type,token) 	         	      return new Type(ident.getType().isReadOnly(), ident.getType().getType(), t);   	   }          }  }  // #x| ARRAYLEN(){  // Type(readonly,type,token)  return new Type(false,Type.INT,t);}}/** UnaryExpr = [AddOp] PrimaryExpr - >  +/-  True, x , y[2], #x, calc(x) */Type UNARYEXPR() :{		Type returnType;	Token t = null;}{  // Primary Expression with optional Addoperation in front  [ t = < ADDOP > ] returnType = PRIMARYEXPR()  {    // if +/- in front and returnType is Bool or Arraytype - > Error    if(t != null && (returnType.getType() == Type.BOOL || returnType instanceof ArrayType))    {    	throw new YAPLException(CompilerError.IllegalOp1Type,null, t);    }    else    {        // if +/- is not null - > set it to type    	if(t!=null){    		returnType.setToken(t);    	}    	       	return returnType;    }  }}/** MulExpr = UnaryExpr { MulOp UnaryExpr } - > y[2] * x * 2 , x * 3 */Type MULEXPR() :{  	// More than one type variable is needed to check 'recursive' the type compatibility	Type type;	Type returnType;	Token t;}{  // Set the first return type   returnType = UNARYEXPR()    (   t = < MULOP > type = UNARYEXPR()   {     // next expression must not be a Bool and equivalent to the first type - > Error      if((returnType.getType() != Type.BOOL && returnType.getType() != type.getType()))     {       throw new YAPLException(CompilerError.IllegalOp2Type,null, t);     }	 // if one of the two (or both) types are Arrays - > Error     else if( type instanceof ArrayType || returnType instanceof ArrayType)     {       throw new YAPLException(CompilerError.IllegalOp2Type,null, t);     }	 // both are of same type and mulOp can be applied     else     {       returnType.setToken(t);     }        }  )*  {        return returnType;  }}/** AddExpr = MulExpr { AddOp MulExpr } (Defines also the 'binding') - > x*y + a[2] */Type ADDEXPR() :{  // More than one type variable is needed to check 'recursive' the type compatibility	Type type;	Type returnType;	Token t;}{  // Set the first return type  returnType = MULEXPR()  (   t = < ADDOP > type = MULEXPR()   {     // next expression must not be a Bool and equivalent to the first type - > Error     if((returnType.getType() != Type.BOOL && returnType.getType() != type.getType()))     {       throw new YAPLException(CompilerError.IllegalOp2Type,null, t);     }	 // if one of the two (or both) types are Arrays - > Error     else if( type instanceof ArrayType || returnType instanceof ArrayType)     {       throw new YAPLException(CompilerError.IllegalOp2Type,null, t);     } 	// both are of same type and AddOp can be applied     else     {              returnType.setToken(t);     }        }  )*  {        return returnType;  }}/**  */Type RELEXPR() :{	Type type;	Type returnType;	Token t;}{  returnType = ADDEXPR() [ t = < RELOP > type = ADDEXPR()	{	  if(returnType.getType() == Type.BOOL || type.getType() == Type.BOOL	  	|| type instanceof ArrayType || returnType instanceof ArrayType)	  	{	  	  throw new YAPLException(CompilerError.IllegalRelOpType,null, t);	  	}else	  	{	  	  returnType = new Type(false, Type.BOOL, type.getToken());	  	}	  		}  ]  {        return returnType;  }}Type EQUALEXPR() :{	Token t;	Type type;	Type returnType;}{  returnType = RELEXPR() [ t = < EQUALOP > type = RELEXPR()	{	  if(returnType.getType() != type.getType() || (type instanceof ArrayType && !(returnType instanceof ArrayType)))	  {	    throw new YAPLException(CompilerError.IllegalEqualOpType,null,t);	  }	  returnType = new Type(false,Type.BOOL,type.getToken());	}  ]  {        return returnType;  }}Type CONDANDEXPR() :{	Type type;	Type returnType;	Token t;}{  returnType = EQUALEXPR()  (    t = < AND > type = EQUALEXPR()    {		if(returnType.getType() != Type.BOOL			|| type.getType() != Type.BOOL			|| type instanceof ArrayType			|| returnType instanceof ArrayType)			{			  throw new YAPLException(CompilerError.IllegalOp2Type,null,t);			}		returnType = new Type(false,Type.BOOL,type.getToken());	     }  )*  {        return returnType;  }}// Multidimensional ArraysType CREATIONEXPR() :{	Token t;	Token t_sec;	Type type;	LinkedList<Type> types = new LinkedList<Type>();	int dim = 1;}{  < NEW > t = PRIMTYPE() < LBRACKET > type = EXPR() t_sec = < RBRACKET >  {    if(type.getType() == Type.BOOL)    {      throw new YAPLException(CompilerError.BadArraySelector,null,t_sec);    }  }  (    < LBRACKET > type = EXPR() t_sec = < RBRACKET >    {            if(type.getType() == Type.BOOL)      {        throw new YAPLException(CompilerError.BadArraySelector,null,t_sec);      }      dim++;    }  )*  {        return new ArrayType(false,Type.getTypeOfImage(t.image),t,dim);  }}Type EXPR() :{  	Token t;  		Type type;	Type returnType;}{  returnType = CONDANDEXPR()  (    t = < OR > type = CONDANDEXPR()    {            if(type.getType() != Type.BOOL || returnType.getType() != Type.BOOL)      {        throw new YAPLException(CompilerError.IllegalOp2Type,null,t);      }else      {                returnType = new Type(false,Type.BOOL,type.getToken());      }    }  )*  {        return returnType;  }| returnType = CREATIONEXPR(){    return returnType; }}int ARGUMENTLIST(Symbol procedureName) :{	int arguments = 1;	int counter = 1;	Symbol start = procedureName.getNextSymbol();	argumentList = new LinkedList<Type >();	LinkedList<Type > tempList = new LinkedList<Type >();	Type type;	}{    type = EXPR()  {    argumentList.add(type);        tempList.add(type);  }    (        < COMMA > type = EXPR()    {      argumentList.add(type);      tempList.add(type);      arguments++;    }     )*  {        while(start != null && !argumentList.isEmpty())    {      if(procedureName.getName().equals("writebool") && argumentList.getFirst().getType() == 2)      {              }	  else if(start.getType().getType() != argumentList.getFirst().getType())      {                              argumentList.getFirst().getToken().setImage("" + counter);                throw new YAPLException(CompilerError.ArgNotApplicable,procedureName,argumentList.getFirst().getToken());      }else if(start.getType() instanceof ArrayType      		&& argumentList.getFirst() instanceof ArrayType			&& (((ArrayType)argumentList.getFirst()).getDimension()				!=((ArrayType)start.getType()).getDimension())      		)      {        argumentList.getFirst().getToken().setImage("" + counter);                throw new YAPLException(CompilerError.ArgNotApplicable,procedureName,argumentList.getFirst().getToken());      }else if((start.getType() instanceof ArrayType)				&& ((ArrayType)argumentList.getFirst()).isReadOnly()				&& !start.getType().isReadOnly()      			)            {        argumentList.getFirst().getToken().setImage("" + counter);                throw new YAPLException(CompilerError.ReadonlyArg,procedureName,argumentList.getFirst().getToken());      }      counter++;      start = start.getNextSymbol();      argumentList.removeFirst();    }        if(argumentList.size() > 0)    {            argumentList.getFirst().getToken().setImage("" + counter);      throw new YAPLException(CompilerError.ArgNotApplicable,procedureName,argumentList.getFirst().getToken());    }    argumentList = tempList;    return arguments;  }}Type PROCEDURECALL() :{  Token t;  Token t_sec;  Type type;  int arguments = 0;}{  t = < IDENT >   {        Symbol ident = symTable.lookup(t.image);    if (ident != null && (ident.getKind() != Symbol.Procedure))    {      // wrong type not an array      throw new YAPLException(CompilerError.SymbolIllegalUse, ident, t);    }    else if (ident == null)    {      // Array not declared      throw new YAPLException(CompilerError.IdentNotDecl, ident, t);    }	  }  < LPAR > [ arguments = ARGUMENTLIST(ident) ] t_sec = < RPAR >  {      	// Count arguments      	Symbol start = ident.getNextSymbol();      	int counter = 0;		while(start != null)		{		  start = start.getNextSymbol();		  counter++;		  		}		if(counter > arguments)		{		  throw new YAPLException(CompilerError.TooFewArgs,ident,t_sec);		}		      	    	if(ident.getType() == null)    	{    	      		type = new Type(false, Type.OTHER, t);    	}    	else if(ident.getType() instanceof ArrayType)    	{    	         		type = new ArrayType(false,ident.getType().getType(), t, ((ArrayType)ident.getType()).getDimension());        }    	else    	{    	         		type = new Type(false, ident.getType().getType(), t);        }		/** CodeGen for procedurecall **/        cg.callProcedure(symTable.lookup(t.image),argumentList,variablesMap);        		return type;     }  }void ASSIGNMENT() :{  Token t;  Token t_sec;  Type type;  boolean selectorUsed = false;  }{  t = < IDENT > [ SELECTOR(){selectorUsed = true;}] t_sec = ":=" type = EXPR()  {        Symbol assi = symTable.lookup(t.image);    int kind;    if(assi != null)    {       kind = assi.getKind();    }    else    {       throw new YAPLException(CompilerError.IdentNotDecl, assi, t);    }    if (kind == Symbol.Constant || (kind != Symbol.Variable && kind != Symbol.Parameter))    {      throw new YAPLException(CompilerError.SymbolIllegalUse, assi, t);    }    // Type Checks				    if(assi.getType().isReadOnly())    {      throw new YAPLException(CompilerError.ReadonlyAssign, assi, t);    }else if(      		 !(      		   (		          !(assi.getType() instanceof ArrayType)		          && !(type instanceof ArrayType)		          && assi.getType().getType()==type.getType()		        )      		    ||      		     (      		      (assi.getType() instanceof ArrayType)      		   	  && (type instanceof ArrayType)      		   	  && (((ArrayType)assi.getType()).getDimension() == ((ArrayType)type).getDimension())      		   	)		        		        ||		         (		           selectorUsed		           && (assi.getType() instanceof ArrayType)		           && !(type instanceof ArrayType)		           && (assi.getType().getType() == type.getType())		         )		             		 			         )		   )		{		  	      		throw new YAPLException(CompilerError.TypeMismatchAssign, assi, t_sec);          	}    	/** Code Generation **/   	AttribImpl attrib = (AttribImpl) variablesMap.get(t.image);   	AttribImpl expr = new AttribImpl();   	expr.setType(type);   	cg.assign(attrib,expr);       }}void IFSTATEMENT() :{  		Type type;	}{  < IF > type = EXPR() < THEN >  {		if(type.getType() != Type.BOOL)		{		  		  throw new YAPLException(CompilerError.CondNotBool,null,type.getToken());		}	     }   STATEMENTLIST() [ < ELSE > STATEMENTLIST() ] < ENDIF >}void WHILESTATEMENT() :{		Type type;}{  < WHILE > type = EXPR() < DO >{  		if(type.getType() != Type.BOOL)		{		  		  throw new YAPLException(CompilerError.CondNotBool,null,type.getToken());		}}  STATEMENTLIST() < ENDWHILE >}void RETURNSTATEMENT() :{  Type type = null;  Token t;}{  t = < RETURN >  {    set_return = true;  }  [ type = EXPR()]  {    if(currentProcedureSymbol == null && type != null)    {      if(type == null)      {              	throw new YAPLException(CompilerError.IllegalRetValMain,currentProcedureSymbol,t);      }else      {        throw new YAPLException(CompilerError.IllegalRetValMain,currentProcedureSymbol,type.getToken());      }      	          }    else if(type != null && returnType == null)    {            throw new YAPLException(CompilerError.IllegalRetValProc,currentProcedureSymbol,type.getToken());    }    else if(type == null && returnType != null)    {           throw new YAPLException(CompilerError.InvalidReturnType,currentProcedureSymbol,t);    }    else if(type != null && returnType != null && type.getType() != returnType.getType())    {           throw new YAPLException(CompilerError.InvalidReturnType,currentProcedureSymbol,type.getToken());    }            }}void WRITESTATEMENT() :{Token t;}{  < WRITE > t = < STRING >  {    cg.writeString(t.image);  }}void STATEMENT() :{}{  IFSTATEMENT()| WHILESTATEMENT()| RETURNSTATEMENT()| WRITESTATEMENT()| LOOKAHEAD(2)  ASSIGNMENT()| PROCEDURECALL()| BLOCK()}void STATEMENTLIST() :{}{  (    STATEMENT() < SEMICOLON >  )*}Token BLOCK() :{	Token t;}{  {    symTable.openScope(false);  }  [ DECL() ] < BEGIN > STATEMENTLIST() t = < END >  {    symTable.closeScope();    return t;  }}Token PRIMTYPE() :{	Token t;	}{ t = < INTEGER > {      return t; } | t = < BOOLEAN >{      return t;}}Type TYPE() :{  Token t;  int dim = 0;}{  t = PRIMTYPE() (< LBRACKET > < RBRACKET >  {        dim++;  }  )*  {    if (dim > 0) return new ArrayType(false, Type.getTypeOfImage(t.image), t, dim);    else return new Type(false, Type.getTypeOfImage(t.image), t);  }}Type RETURNTYPE() :{	Token t = null;	Type type = null;}{ t = < VOID > {      return new Type(false,Type.OTHER,t); }| type = TYPE(){  	return type;}}void CONSTDECL() :{  Token t;  Token t_sec;  Type type;}{  < CONST > t = < IDENT > < IS > t_sec = LITERAL() < SEMICOLON >  {    Symbol constdec = symTable.lookupCurrentScope(t.image);    if (constdec != null)    {      throw new YAPLException(CompilerError.SymbolExists, constdec, t);    }    else    {      if (t_sec.image.equals("True") || t_sec.image.equals("False")) type = new Type(true, Type.BOOL, t_sec);      else type = new Type(true, Type.INT, t_sec);      constdec = new SymbolImpl(Symbol.Constant, t.image);      constdec.setType(type);      constdec.setGlobal(true);      symTable.addSymbol(constdec);	      /** Code Generation **/            AttribImpl attrib = new AttribImpl();      attrib.setType(type);            cg.allocVariable(constdec);      attrib.setOffset(constdec.getOffset());            variablesMap.put(t.image,attrib);      //System.out.println(constdec.getOffset());    }  }}void VARDECL() :{  Token t;  Type type;}{  type = TYPE() t = < IDENT >  {    Symbol vardecl = symTable.lookupCurrentScope(t.image);    if (vardecl != null)    {      throw new YAPLException(CompilerError.SymbolExists, vardecl, t);    }    else    {      vardecl = new SymbolImpl(Symbol.Variable, t.image);      symTable.addSymbol(vardecl);            vardecl.setType(type);       /** Code Generation **/            AttribImpl attrib = new AttribImpl();      attrib.setType(type);            cg.allocVariable(vardecl);      attrib.setOffset(vardecl.getOffset());                 variablesMap.put(t.image,attrib);      //System.out.println(constdec.getOffset());    }  }  (    < COMMA > t = < IDENT >    {      vardecl = symTable.lookupCurrentScope(t.image);      if (vardecl != null)      {        throw new YAPLException(CompilerError.SymbolExists, vardecl, t);      }      else      {        vardecl = new SymbolImpl(Symbol.Variable, t.image);                vardecl.setType(type);                symTable.addSymbol(vardecl);         /** Code Generation **/      	      AttribImpl attrib = new AttribImpl();	      attrib.setType(type);      	      cg.allocVariable(vardecl);	      attrib.setOffset(vardecl.getOffset());      	      variablesMap.put(t.image,attrib);	      //System.out.println(constdec.getOffset());      }    }  )*  < SEMICOLON >}void DECL() :{}{  < DECLARE >  (    CONSTDECL()  | VARDECL()  )*}Symbol FORMALPARAM() :{  Token t;  Type type;  boolean readOnly = false;  }{  [ < READONLY > { readOnly = true; }] type = TYPE() t = < IDENT >  {    Symbol form = symTable.lookupCurrentScope(t.image);    if (form != null)    {      throw new YAPLException(CompilerError.SymbolExists, form, t);    }else if(!(type instanceof ArrayType) && readOnly)    {      throw new YAPLException(CompilerError.ReadonlyNotArray, form, t);    }    else    {      type.setReadOnly(readOnly);      form = new SymbolImpl(Symbol.Parameter, t.image);      form.setType(type);      symTable.addSymbol(form);      return form;    }  }}Symbol FORMALPARAMLIST() :{  Symbol returnSymbol;  Symbol s1,s2;}{  s1 = FORMALPARAM()  {    returnSymbol = s1;  }  (      < COMMA > s2 = FORMALPARAM()    { s1.setNextSymbol(s2);      s1 = s2;    }  )*  {    return returnSymbol;  }}void PROCEDURE() :{  Token t;  Token t_sec;  Type type;  Symbol startSymbol = null;}{  < PROCEDURE > type = RETURNTYPE() t = < IDENT >  {        Symbol procedure = symTable.lookupCurrentScope(t.image);    if (procedure != null)    {      throw new YAPLException(CompilerError.SymbolExists, procedure, t);    }    else    {      procedure = new SymbolImpl(Symbol.Procedure, t.image);      procedure.setType(type);      currentProcedureSymbol = procedure;      	  if(type.getType() == Type.OTHER)	  {	    	    need_return = false;	    returnType = null;	    	    	  }else	  {	    need_return = true;	    returnType = type;	    	  }	  set_return = false;	  	             symTable.addSymbol(procedure);      symTable.openScope(false);      symTable.setParentSymbol(procedure);                }      }  < LPAR > [startSymbol = FORMALPARAMLIST()]  {    if(startSymbol != null)    {      procedure.setNextSymbol(startSymbol);    }  }  < RPAR > t_sec = BLOCK() t = < IDENT >  {    //System.out.println(returnType.getType() + " - " +  procedure.getType().getType());    Symbol procedureClose = symTable.getNearestParentSymbol(Symbol.Procedure);    if (!procedureClose.getName().equals(t.image))    {      throw new YAPLException(CompilerError.EndIdentMismatch, procedureClose, t);    }    else if(need_return && (      						!(( (procedure.getType() instanceof ArrayType)    							&& (type instanceof ArrayType)    							&& (((ArrayType)procedure.getType()).getDimension() == ((ArrayType)type).getDimension()))    						||		      			 	(!(procedure.getType() instanceof ArrayType)		      			 		&& !(type instanceof ArrayType)		      			 		&& procedure.getType().getType()== type.getType()))		         		 	)		         		 	)    {      throw new YAPLException(CompilerError.InvalidReturnType,procedure,t_sec);    }else if(need_return && !set_return)    {      throw new YAPLException(CompilerError.MissingReturn,procedure,t_sec);    }        else    {       symTable.closeScope();       currentProcedureSymbol = null;    }  }  < SEMICOLON >}void PROGRAM() :{  Token t;}{  < PROGRAM > t = < IDENT >  {    program_name = t.image;    Symbol programStart = new SymbolImpl(Symbol.Program, t.image);    /** Open Universe Scope which contains predefined Procedures */    symTable.openScope(true);    symTable.setParentSymbol(null);        /** put predefined procedures in symbol table */    pre_writeln = new SymbolImpl(Symbol.Procedure, "writeln");    symTable.addSymbol(pre_writeln);        pre_writeint = new SymbolImpl(Symbol.Procedure, "writeint");	SymbolImpl predefinedArgument = new SymbolImpl(Symbol.Parameter,"");	predefinedArgument.setType(new Type(false, Type.INT,null));	pre_writeint.setNextSymbol(predefinedArgument);        pre_writeint.setType(new Type(false, Type.INT,null));    symTable.addSymbol(pre_writeint);        pre_writebool = new SymbolImpl(Symbol.Procedure, "writebool");    predefinedArgument = new SymbolImpl(Symbol.Parameter,"");    	predefinedArgument.setType(new Type(false, Type.BOOL,null));	pre_writebool.setNextSymbol(predefinedArgument);        //pre_writebool.setType(new Type(false, Type.BOOL,null));    symTable.addSymbol(pre_writebool);        pre_readint = new SymbolImpl(Symbol.Procedure, "readint");    pre_readint.setType(new Type(false, Type.INT,null));    symTable.addSymbol(pre_readint);        /** Open Programm Scope */    symTable.openScope(false);    symTable.setParentSymbol(programStart);    /** Generate Code for Programm Start **/    cg.back.enterMain();  }  (    DECL()  | PROCEDURE()  )*  < BEGIN > STATEMENTLIST() < END > t = < IDENT >  {    Symbol endProgram = symTable.getNearestParentSymbol(Symbol.Program);    if (!endProgram.getName().equals(t.image)) throw new YAPLException(CompilerError.EndIdentMismatch, endProgram, t);    /** Close Program Scope */    symTable.closeScope();    /** Close Universe Scope */    symTable.closeScope();    /** Generate Code for Programm End **/    cg.back.exitMain("main_end");  }  < DOT >}/* Predefined Functions *//* Root node for production */void Start() :{}{  PROGRAM()}